<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>wyrm package &mdash; Wyrm 1.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="top" title="Wyrm 1.0 documentation" href="../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Wyrm 1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="wyrm-package">
<h1>wyrm package<a class="headerlink" href="#wyrm-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-wyrm.io">
<span id="wyrm-io-module"></span><h2>wyrm.io module<a class="headerlink" href="#module-wyrm.io" title="Permalink to this headline">¶</a></h2>
<p>Various input/output methods.</p>
<p>This module provides methods for loading and saving data from- and into
various formats.</p>
<dl class="class">
<dt id="wyrm.io.PyffComm">
<em class="property">class </em><code class="descclassname">wyrm.io.</code><code class="descname">PyffComm</code><span class="sig-paren">(</span><em>host='localhost'</em>, <em>port=12345</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/io.html#PyffComm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.io.PyffComm" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="http://docs.python.org/library/functions.html#object" title="(in Python v2.7)"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a></p>
<p>Pyff communication object.</p>
<p>This class allows for communication with a running Pyff <a class="footnote-reference" href="#id2" id="id1">[1]</a>
instance. It uses the json protocol, so you have to start Pyff with
the <code class="docutils literal"><span class="pre">--protocol=json</span></code> parameter.</p>
<p>Receiving data from Pyff (i.e. the available feedbacks and
variables) is not supported for now.</p>
<p class="rubric">Examples</p>
<p>This is an example session, demonstrating how to load a feedback
application, set a variable, start it, quit it and closing Pyff in
the end.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">pyff</span> <span class="o">=</span> <span class="n">PyffComm</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pyff</span><span class="o">.</span><span class="n">send_init</span><span class="p">(</span><span class="s">&#39;TrivialPong&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pyff</span><span class="o">.</span><span class="n">set_variables</span><span class="p">({</span><span class="s">&#39;FPS&#39;</span><span class="p">:</span> <span class="mi">30</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pyff</span><span class="o">.</span><span class="n">play</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pyff</span><span class="o">.</span><span class="n">quit</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pyff</span><span class="o">.</span><span class="n">quit_pyff</span><span class="p">()</span>
</pre></div>
</div>
<p class="rubric">References</p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Bastian Venthur, Simon Scholler, John Williamson, Sven Dähne,
Matthias S Treder, Maria T Kramarek, Klaus-Robert Müller and
Benjamin Blankertz. Pyff&#8212;A Pythonic Framework for Feedback
Applications and Stimulus Presentation in Neuroscience.
Frontiers in Neuroscience. 2010. doi: 10.3389/fnins.2010.00179.</td></tr>
</tbody>
</table>
<dl class="method">
<dt id="wyrm.io.PyffComm.pause">
<code class="descname">pause</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/io.html#PyffComm.pause"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.io.PyffComm.pause" title="Permalink to this definition">¶</a></dt>
<dd><p>Pause the feedback.</p>
</dd></dl>

<dl class="method">
<dt id="wyrm.io.PyffComm.play">
<code class="descname">play</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/io.html#PyffComm.play"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.io.PyffComm.play" title="Permalink to this definition">¶</a></dt>
<dd><p>Start the feedback.</p>
</dd></dl>

<dl class="method">
<dt id="wyrm.io.PyffComm.quit">
<code class="descname">quit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/io.html#PyffComm.quit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.io.PyffComm.quit" title="Permalink to this definition">¶</a></dt>
<dd><p>Quit the feedback.</p>
</dd></dl>

<dl class="method">
<dt id="wyrm.io.PyffComm.quit_pyff">
<code class="descname">quit_pyff</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/io.html#PyffComm.quit_pyff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.io.PyffComm.quit_pyff" title="Permalink to this definition">¶</a></dt>
<dd><p>Quit Pyff.</p>
</dd></dl>

<dl class="method">
<dt id="wyrm.io.PyffComm.send_control_signal">
<code class="descname">send_control_signal</code><span class="sig-paren">(</span><em>variables</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/io.html#PyffComm.send_control_signal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.io.PyffComm.send_control_signal" title="Permalink to this definition">¶</a></dt>
<dd><p>Send a control signal to the running feedback.</p>
<p>This method is used to send events to the feedback like a new
classifier output.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>variables</strong> (<a class="reference external" href="http://docs.python.org/library/stdtypes.html#dict" title="(in Python v2.7)"><em>dict</em></a>) &#8211; the keys are the variable names and the values the values.
Those variables sent by the control signal are not set
directly in the feedback. If you want this behave use
<a class="reference internal" href="#wyrm.io.PyffComm.set_variables" title="wyrm.io.PyffComm.set_variables"><code class="xref py py-func docutils literal"><span class="pre">set_variables()</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="wyrm.io.PyffComm.send_init">
<code class="descname">send_init</code><span class="sig-paren">(</span><em>fb</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/io.html#PyffComm.send_init"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.io.PyffComm.send_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a Feedback.</p>
<p>This method sends Pyff the <code class="docutils literal"><span class="pre">send_init(feedback)</span></code> command which
loads a feedback.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>fb</strong> (<a class="reference external" href="http://docs.python.org/library/string.html#module-string" title="(in Python v2.7)"><em>string</em></a>) &#8211; The name of the feedback.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="wyrm.io.PyffComm.send_interaction_signal">
<code class="descname">send_interaction_signal</code><span class="sig-paren">(</span><em>cmd</em>, <em>data=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/io.html#PyffComm.send_interaction_signal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.io.PyffComm.send_interaction_signal" title="Permalink to this definition">¶</a></dt>
<dd><p>Send interaction signal to Pyff.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This method is used internally to send low level JSON
messages to Pyff. You should not use this method directly.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>cmd</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; </li>
<li><strong>data</strong> (<a class="reference external" href="http://docs.python.org/library/stdtypes.html#dict" title="(in Python v2.7)"><em>dict</em></a>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="wyrm.io.PyffComm.set_variables">
<code class="descname">set_variables</code><span class="sig-paren">(</span><em>variables</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/io.html#PyffComm.set_variables"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.io.PyffComm.set_variables" title="Permalink to this definition">¶</a></dt>
<dd><p>Set internal variables in the feedback.</p>
<p>Use this method to create or modify instance variables of the
currently running feedback.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>variables</strong> (<a class="reference external" href="http://docs.python.org/library/stdtypes.html#dict" title="(in Python v2.7)"><em>dict</em></a>) &#8211; The variable names are the keys, the values are the values
of the variables.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="wyrm.io.PyffComm.stop">
<code class="descname">stop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/io.html#PyffComm.stop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.io.PyffComm.stop" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the feedback.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="wyrm.io.convert_mushu_data">
<code class="descclassname">wyrm.io.</code><code class="descname">convert_mushu_data</code><span class="sig-paren">(</span><em>data</em>, <em>markers</em>, <em>fs</em>, <em>channels</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/io.html#convert_mushu_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.io.convert_mushu_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert mushu data into wyrm&#8217;s <code class="docutils literal"><span class="pre">Data</span></code> format.</p>
<p>This convenience method creates a continuous <code class="docutils literal"><span class="pre">Data</span></code> object from
the parameters given. The timeaxis always starts from zero and its
values are calculated from the sampling frequency <code class="docutils literal"><span class="pre">fs</span></code> and the
length of <code class="docutils literal"><span class="pre">data</span></code>. The <code class="docutils literal"><span class="pre">names</span></code> and <code class="docutils literal"><span class="pre">units</span></code> attributes are
filled with default vaules.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<em>2d array</em>) &#8211; an 2 dimensional numpy array with the axes: (time, channel)</li>
<li><strong>markers</strong> (<em>list of tuples: (float, str)</em>) &#8211; a list of markers. Each element is a tuple of timestamp and
string. The timestamp is the time in ms relative to the onset of
the block of data. Note that negative values are <em>allowed</em> as
well as values bigger than the length of the block of data
returned. That is to be interpreted as a marker from the last
block and a marker for a future block respectively.</li>
<li><strong>fs</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; the sampling frequency, this number is used to calculate the
timeaxis for the data</li>
<li><strong>channels</strong> (<em>list or 1d array of strings</em>) &#8211; the channel names</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>cnt</strong></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">continuous <code class="docutils literal"><span class="pre">Data</span></code> object</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Assuming that <code class="docutils literal"><span class="pre">amp</span></code> is an Amplifier instance from <code class="docutils literal"><span class="pre">libmushu</span></code>,
already configured but not started yet:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">amp_fs</span> <span class="o">=</span> <span class="n">amp</span><span class="o">.</span><span class="n">get_sampling_frequency</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">amp_channels</span> <span class="o">=</span> <span class="n">amp</span><span class="o">.</span><span class="n">get_channels</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">amp</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">data</span><span class="p">,</span> <span class="n">markers</span> <span class="o">=</span> <span class="n">amp</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>
<span class="gp">... </span>    <span class="n">cnt</span> <span class="o">=</span> <span class="n">convert_mushu_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">markers</span><span class="p">,</span> <span class="n">amp_fs</span><span class="p">,</span> <span class="n">amp_channels</span><span class="p">)</span>
<span class="gp">... </span>    <span class="c"># some more code</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">amp</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
</pre></div>
</div>
<p class="rubric">References</p>
<p><a class="reference external" href="https://github.com/bbci/mushu">https://github.com/bbci/mushu</a></p>
</dd></dl>

<dl class="function">
<dt id="wyrm.io.load">
<code class="descclassname">wyrm.io.</code><code class="descname">load</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/io.html#load"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.io.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a <code class="docutils literal"><span class="pre">Data</span></code> object from a file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; the file to load the data from</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>dat</strong> &#8211;
the data loaded from the file</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data">Data</a></td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#wyrm.io.save" title="wyrm.io.save"><code class="xref py py-func docutils literal"><span class="pre">save()</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">io</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="s">&#39;foo.npy&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat2</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s">&#39;foo.npy&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.io.load_bcicomp3_ds1">
<code class="descclassname">wyrm.io.</code><code class="descname">load_bcicomp3_ds1</code><span class="sig-paren">(</span><em>dirname</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/io.html#load_bcicomp3_ds1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.io.load_bcicomp3_ds1" title="Permalink to this definition">¶</a></dt>
<dd><p>Load the BCI Competition III Data Set 1.</p>
<p>This method loads the data set and converts it into Wyrm&#8217;s <code class="docutils literal"><span class="pre">Data</span></code>
format. Before you use it, you have to download the training- and
test data in Matlab format and unpack it into a directory.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you need the true labels of the test sets, you&#8217;ll have to
download them separately from
<a class="reference external" href="http://bbci.de/competition/iii/results/index.html#labels">http://bbci.de/competition/iii/results/index.html#labels</a></p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dirname</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; the directory where the <code class="docutils literal"><span class="pre">Competition_train.mat</span></code> and
<code class="docutils literal"><span class="pre">Competition_test.mat</span></code> are located</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>epo_train, epo_test</strong></td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">epoched <code class="docutils literal"><span class="pre">Data</span></code> objects</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">epo_test</span><span class="p">,</span> <span class="n">epo_train</span> <span class="o">=</span> <span class="n">load_bcicomp3_ds1</span><span class="p">(</span><span class="s">&#39;/home/foo/bcicomp3_dataset1/&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.io.load_bcicomp3_ds2">
<code class="descclassname">wyrm.io.</code><code class="descname">load_bcicomp3_ds2</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/io.html#load_bcicomp3_ds2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.io.load_bcicomp3_ds2" title="Permalink to this definition">¶</a></dt>
<dd><p>Load the BCI Competition III Data Set 2.</p>
<p>This method loads the data set and converts it into Wyrm&#8217;s <code class="docutils literal"><span class="pre">Data</span></code>
format. Before you use it, you have to download the data set in
Matlab format and unpack it. The directory with the extracted files
must contain the <code class="docutils literal"><span class="pre">Subject_*.mat</span></code>- and the <code class="docutils literal"><span class="pre">eloc64.txt</span></code> files.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you need the true labels of the test sets, you&#8217;ll have to
download them separately from
<a class="reference external" href="http://bbci.de/competition/iii/results/index.html#labels">http://bbci.de/competition/iii/results/index.html#labels</a></p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; The path to the matlab file to load</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>cnt</strong></td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">continuous <cite>Data</cite> object</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="n">load_bcicomp3_ds2</span><span class="p">(</span><span class="s">&#39;/home/foo/data/Subject_A_Train.mat&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.io.load_brain_vision_data">
<code class="descclassname">wyrm.io.</code><code class="descname">load_brain_vision_data</code><span class="sig-paren">(</span><em>vhdr</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/io.html#load_brain_vision_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.io.load_brain_vision_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Load Brain Vision data from a file.</p>
<p>This methods loads the continuous EEG data, and returns a <code class="docutils literal"><span class="pre">Data</span></code>
object of continuous data <code class="docutils literal"><span class="pre">[time,</span> <span class="pre">channel]</span></code>, along with the
markers and the sampling frequency. The EEG data is returned in
micro Volt.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>vhdr</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; Path to a VHDR file</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>dat</strong> &#8211;
Continuous Data with the additional attributes <code class="docutils literal"><span class="pre">.fs</span></code> for the
sampling frequency and <code class="docutils literal"><span class="pre">.marker</span></code> for a list of markers. Each
marker is a tuple of <code class="docutils literal"><span class="pre">(time</span> <span class="pre">in</span> <span class="pre">ms,</span> <span class="pre">marker)</span></code>.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data">Data</a></td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> &#8211;
If one of the consistency checks fails</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="n">load_brain_vision_data</span><span class="p">(</span><span class="s">&#39;path/to/vhdr&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">fs</span>
<span class="go">1000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(54628, 61)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.io.load_mushu_data">
<code class="descclassname">wyrm.io.</code><code class="descname">load_mushu_data</code><span class="sig-paren">(</span><em>meta</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/io.html#load_mushu_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.io.load_mushu_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Load saved EEG data in Mushu&#8217;s format.</p>
<p>This method loads saved data in Mushu&#8217;s format and returns a
continuous <code class="docutils literal"><span class="pre">Data</span></code> object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>meta</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; Path to <cite>.meta</cite> file. A Mushu recording consists of three
different files: <cite>.eeg</cite>, <cite>.marker</cite>, and <cite>.meta</cite>.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>dat</strong> &#8211;
Continuous Data object</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data">Data</a></td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="n">load_mushu_data</span><span class="p">(</span><span class="s">&#39;testrecording.meta&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.io.save">
<code class="descclassname">wyrm.io.</code><code class="descname">save</code><span class="sig-paren">(</span><em>dat</em>, <em>filename</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/io.html#save"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.io.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a <code class="docutils literal"><span class="pre">Data</span></code> object into a NumPy .npy file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dat</strong> (<a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data"><em>Data</em></a>) &#8211; <cite>Data</cite> object</li>
<li><strong>filename</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; Filename of the file to save to. If the filename does not end
with <code class="docutils literal"><span class="pre">.npy</span></code>, the <code class="docutils literal"><span class="pre">.npy</span></code> extension will be automatically
appended.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#wyrm.io.load" title="wyrm.io.load"><code class="xref py py-func docutils literal"><span class="pre">load()</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">io</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="s">&#39;foo.npy&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat2</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s">&#39;foo.npy&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-wyrm.plot">
<span id="wyrm-plot-module"></span><h2>wyrm.plot module<a class="headerlink" href="#module-wyrm.plot" title="Permalink to this headline">¶</a></h2>
<p>Plotting methods.</p>
<p>This module contains various plotting methods. There are two types of
plotting methods: the Primitives and the Composites. The Primitives are
the most basic and offer simple, single-plot representations. The
Composites are composed of several primitives and offer more complex
representations.</p>
<p>The primitive plots are those whose name begin with <code class="docutils literal"><span class="pre">ax_</span></code>, (e.g.
<code class="docutils literal"><span class="pre">ax_scalp</span></code>).</p>
<p>In order to get more reasonable defaults for colors etc. you can call
the modules <a class="reference internal" href="#wyrm.plot.beautify" title="wyrm.plot.beautify"><code class="xref py py-func docutils literal"><span class="pre">beautify()</span></code></a> method:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">wyrm</span> <span class="kn">import</span> <span class="n">plot</span>
<span class="n">plot</span><span class="o">.</span><span class="n">beautify</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>This module needs heavy reworking! We have yet to find a consistent
way to handle primitive and composite plots, deal with the fact that
some plots just manipulate axes, while others operate on figures and
have to decide on which layer of matplotlib we want to deal with
(i.e. pyplot, artist or even pylab).</p>
<p class="last">The API of this module will change and you should not rely on any
method here.</p>
</div>
<dl class="function">
<dt id="wyrm.plot.ax_colorbar">
<code class="descclassname">wyrm.plot.</code><code class="descname">ax_colorbar</code><span class="sig-paren">(</span><em>vmin</em>, <em>vmax</em>, <em>ax=None</em>, <em>label=None</em>, <em>ticks=None</em>, <em>colormap=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/plot.html#ax_colorbar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.plot.ax_colorbar" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw a color bar</p>
<p>Draws a color bar on an existing axes. The range of the colors is
defined by <code class="docutils literal"><span class="pre">vmin</span></code> and <code class="docutils literal"><span class="pre">vmax</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Unlike the colorbar method from matplotlib, this method does not
automatically create a new axis for the colorbar. It will paint
in the currently active axis instead, overwriting any existing
plots in that axis. Make sure to create a new axis for the
colorbar.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>vmax</strong> (<em>vmin,</em>) &#8211; The minimum and maximum values for the colorbar.</li>
<li><strong>ax</strong> (<em>Axes, optional</em>) &#8211; The axes to draw the scalp plot on. If not provided, the
currently activated axes (i.e. <code class="docutils literal"><span class="pre">gca()</span></code>) will be taken</li>
<li><strong>label</strong> (<em>string, optional</em>) &#8211; The label for the colorbar</li>
<li><strong>ticks</strong> (<em>list, optional</em>) &#8211; The tick positions</li>
<li><strong>colormap</strong> (<em>matplotlib.colors.colormap, optional</em>) &#8211; A colormap to define the color transitions.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ax</strong> &#8211;
the axes on which the plot was drawn</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Axes</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="wyrm.plot.ax_scalp">
<code class="descclassname">wyrm.plot.</code><code class="descname">ax_scalp</code><span class="sig-paren">(</span><em>v</em>, <em>channels</em>, <em>ax=None</em>, <em>annotate=False</em>, <em>vmin=None</em>, <em>vmax=None</em>, <em>colormap=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/plot.html#ax_scalp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.plot.ax_scalp" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw a scalp plot.</p>
<p>Draws a scalp plot on an existing axes. The method takes an array of
values and an array of the corresponding channel names. It matches
the channel names with an internal list of known channels and their
positions to project them correctly on the scalp.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The behaviour for unkown channels is undefined.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>v</strong> (<em>1d-array of floats</em>) &#8211; The values for the channels</li>
<li><strong>channels</strong> (<em>1d array of strings</em>) &#8211; The corresponding channel names for the values in <code class="docutils literal"><span class="pre">v</span></code></li>
<li><strong>ax</strong> (<em>Axes, optional</em>) &#8211; The axes to draw the scalp plot on. If not provided, the
currently activated axes (i.e. <code class="docutils literal"><span class="pre">gca()</span></code>) will be taken</li>
<li><strong>annotate</strong> (<em>Boolean, optional</em>) &#8211; Draw the channel names next to the channel markers.</li>
<li><strong>vmax</strong> (<em>vmin,</em>) &#8211; The display limits for the values in <code class="docutils literal"><span class="pre">v</span></code>. If the data in <code class="docutils literal"><span class="pre">v</span></code>
contains values between -3..3 and <code class="docutils literal"><span class="pre">vmin</span></code> and <code class="docutils literal"><span class="pre">vmax</span></code> are set
to -1 and 1, all values smaller than -1 and bigger than 1 will
appear the same as -1 and 1. If not set, the maximum absolute
value in <code class="docutils literal"><span class="pre">v</span></code> is taken to calculate both values.</li>
<li><strong>colormap</strong> (<em>matplotlib.colors.colormap, optional</em>) &#8211; A colormap to define the color transitions.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ax</strong> &#8211;
the axes on which the plot was drawn</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Axes</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#wyrm.plot.ax_colorbar" title="wyrm.plot.ax_colorbar"><code class="xref py py-func docutils literal"><span class="pre">ax_colorbar()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.plot.beautify">
<code class="descclassname">wyrm.plot.</code><code class="descname">beautify</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/plot.html#beautify"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.plot.beautify" title="Permalink to this definition">¶</a></dt>
<dd><p>Set reasonable defaults matplotlib.</p>
<p>This method replaces matplotlib&#8217;s default rgb/cmyk colors with the
colarized colors. It also does:</p>
<ul class="simple">
<li>re-orders the default color cycle</li>
<li>sets the default linewidth</li>
<li>replaces the defaault &#8216;RdBu&#8217; cmap</li>
<li>sets the default cmap to &#8216;RdBu&#8217;</li>
</ul>
<p class="rubric">Examples</p>
<p>You can safely call <code class="docutils literal"><span class="pre">beautify</span></code> right after you&#8217;ve imported the
<code class="docutils literal"><span class="pre">plot</span></code> module.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">wyrm</span> <span class="kn">import</span> <span class="n">plot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="o">.</span><span class="n">beautify</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.plot.calc_centered_grid">
<code class="descclassname">wyrm.plot.</code><code class="descname">calc_centered_grid</code><span class="sig-paren">(</span><em>cols_list</em>, <em>hpad=0.05</em>, <em>vpad=0.05</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/plot.html#calc_centered_grid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.plot.calc_centered_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates a centered grid of Rectangles and their positions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>cols_list</strong> (<em>[int]</em>) &#8211; List of ints. Every entry represents a row with as many channels
as the value.</li>
<li><strong>hpad</strong> (<em>float, optional</em>) &#8211; The amount of horizontal padding (default: 0.05).</li>
<li><strong>vpad</strong> (<em>float, optional</em>) &#8211; The amount of vertical padding (default: 0.05).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A list of all rectangle positions in the form of [xi, xy, width,
height] sorted from top left to bottom right.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">[[float, float, float, float]]</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Calculates a centered grid with 3 rows of 4, 3 and 2 columns</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">calc_centered_grid</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
<p>Calculates a centered grid with more padding</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">calc_centered_grid</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="n">hpad</span><span class="o">=.</span><span class="mi">1</span><span class="p">,</span> <span class="n">vpad</span><span class="o">=.</span><span class="mi">75</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.plot.get_channelpos">
<code class="descclassname">wyrm.plot.</code><code class="descname">get_channelpos</code><span class="sig-paren">(</span><em>channame</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/plot.html#get_channelpos"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.plot.get_channelpos" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the x/y position of a channel.</p>
<p>This method calculates the stereographic projection of a channel
from <code class="docutils literal"><span class="pre">CHANNEL_10_20</span></code>, suitable for a scalp plot.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>channame</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; Name of the channel, the search is case insensitive.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>x, y</strong> &#8211;
The projected point on the plane if the point is known,
otherwise <code class="docutils literal"><span class="pre">None</span></code></td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">float or None</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="o">.</span><span class="n">get_channelpos</span><span class="p">(</span><span class="s">&#39;C2&#39;</span><span class="p">)</span>
<span class="go">(0.1720792096741632, 0.0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># the channels are case insensitive</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="o">.</span><span class="n">get_channelpos</span><span class="p">(</span><span class="s">&#39;c2&#39;</span><span class="p">)</span>
<span class="go">(0.1720792096741632, 0.0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># lookup for an invalid channel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="o">.</span><span class="n">get_channelpos</span><span class="p">(</span><span class="s">&#39;foo&#39;</span><span class="p">)</span>
<span class="go">None</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.plot.plot_channels">
<code class="descclassname">wyrm.plot.</code><code class="descname">plot_channels</code><span class="sig-paren">(</span><em>dat</em>, <em>chanaxis=-1</em>, <em>otheraxis=-2</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/plot.html#plot_channels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.plot.plot_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot all channels for a continuous.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dat</strong> (<a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data"><em>Data</em></a>) &#8211; </td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="wyrm.plot.plot_scalp">
<code class="descclassname">wyrm.plot.</code><code class="descname">plot_scalp</code><span class="sig-paren">(</span><em>v</em>, <em>channels</em>, <em>levels=25</em>, <em>colormap=None</em>, <em>norm=None</em>, <em>ticks=None</em>, <em>annotate=True</em>, <em>position=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/plot.html#plot_scalp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.plot.plot_scalp" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots the values &#8216;v&#8217; for channels &#8216;channels&#8217; on a scalp.</p>
<p>Calculates the interpolation of the values v for the corresponding
channels &#8216;channels&#8217; and plots it as a contour plot on a scalp. The
degree of gradients as well as the the appearance of the color bar
can be adjusted.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>v</strong> (<em>[value]</em>) &#8211; List containing the values of the channels.</li>
<li><strong>channels</strong> (<em>[String]</em>) &#8211; List containing the channel names.</li>
<li><strong>levels</strong> (<em>int, optional</em>) &#8211; The number of automatically created levels in the contour plot
(default: 25).</li>
<li><strong>colormap</strong> (<em>matplotlib.colors.colormap, optional</em>) &#8211; A colormap to define the color transitions (default: a
blue-white-red colormap).</li>
<li><strong>norm</strong> (<em>matplotlib.colors.norm, optional</em>) &#8211; A norm to define the min and max values (default: &#8216;None&#8217;, values
from -10 to 10 are assumed).</li>
<li><strong>ticks</strong> (<em>array([ints]), optional</em>) &#8211; An array with values to define the ticks on the colorbar
(default: &#8216;None&#8217;, 3 ticks at -10, 0 and 10 are displayed).</li>
<li><strong>annotate</strong> (<em>Boolean, optional</em>) &#8211; Flag to switch channel annotations on or off (default: True).</li>
<li><strong>position</strong> (<em>[x, y, width, height], optional</em>) &#8211; A Rectangle that limits the plot to its boundaries (default:
None).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Returns a pair of Matplotlib.Axes. The first contains the
plotted scalp, the second the corresponding colorbar.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">(Matplotlib.Axes, Matplotlib.Axes)</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Plots the values v for channels &#8216;channels&#8217; on a scalp</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">plot_scalp</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">channels</span><span class="p">)</span>
</pre></div>
</div>
<p>This plot has finer gradients through increasing the levels to 50.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">plot_scalp</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">channels</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
</pre></div>
</div>
<p>This plot has a norm and ticks from 0 to 10</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">clip</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot_scalp</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">channels</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">ticks</span><span class="o">=</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.plot.plot_scalp_ti">
<code class="descclassname">wyrm.plot.</code><code class="descname">plot_scalp_ti</code><span class="sig-paren">(</span><em>v</em>, <em>channels</em>, <em>data</em>, <em>interval</em>, <em>scale_ti=0.1</em>, <em>levels=25</em>, <em>colormap=None</em>, <em>norm=None</em>, <em>ticks=None</em>, <em>annotate=True</em>, <em>position=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/plot.html#plot_scalp_ti"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.plot.plot_scalp_ti" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots a scalp with channels on top</p>
<p>Plots the values v for channels &#8216;channels&#8217; on a scalp as a contour
plot. Additionaly plots the channels in channels_ti as a
timeinterval on top of the scalp plot. The individual channels are
placed over their position on the scalp.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>v</strong> (<em>[value]</em>) &#8211; List containing the values of the channels.</li>
<li><strong>channels</strong> (<em>[String]</em>) &#8211; List containing the channel names.</li>
<li><strong>data</strong> (<a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data"><em>wyrm.types.Data</em></a>) &#8211; Data object containing the continuous data for the overlaying
timeinterval plots.</li>
<li><strong>interval</strong> (<em>[begin, end)</em>) &#8211; Tuple of ints to specify the range of the overlaying
timeinterval plots.</li>
<li><strong>scale_ti</strong> (<em>float, optional</em>) &#8211; The percentage to scale the overlaying timeinterval plots
(default: 0.1).</li>
<li><strong>levels</strong> (<em>int, optional</em>) &#8211; The number of automatically created levels in the contour plot
(default: 25).</li>
<li><strong>colormap</strong> (<em>matplotlib.colors.colormap, optional</em>) &#8211; A colormap to define the color transitions (default: a
blue-white-red colormap).</li>
<li><strong>norm</strong> (<em>matplotlib.colors.norm, optional</em>) &#8211; A norm to define the min and max values. If &#8216;None&#8217;, values from
-10 to 10 are assumed (default: None).</li>
<li><strong>ticks</strong> (<em>array([ints]), optional</em>) &#8211; An array with values to define the ticks on the colorbar
(default: None, 3  ticks at -10, 0 and 10 are displayed).</li>
<li><strong>annotate</strong> (<em>Boolean, optional</em>) &#8211; Flag to switch channel annotations on or off (default: True).</li>
<li><strong>position</strong> (<em>[x, y, width, height], optional</em>) &#8211; A Rectangle that limits the plot to its boundaries (default:
None).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Returns a tuple of first a tuple with the plotted scalp and its
colorbar, then a list of all on top plotted timeintervals.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">((Matplotlib.Axes, Matplotlib.Axes), [Matplotlib.Axes])</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="wyrm.plot.plot_spatio_temporal_r2_values">
<code class="descclassname">wyrm.plot.</code><code class="descname">plot_spatio_temporal_r2_values</code><span class="sig-paren">(</span><em>dat</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/plot.html#plot_spatio_temporal_r2_values"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.plot.plot_spatio_temporal_r2_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the signed r^2 values and plot them in a heatmap.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dat</strong> (<a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data"><em>Data</em></a>) &#8211; epoched data</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="wyrm.plot.plot_spectrogram">
<code class="descclassname">wyrm.plot.</code><code class="descname">plot_spectrogram</code><span class="sig-paren">(</span><em>spectrogram</em>, <em>freqs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/plot.html#plot_spectrogram"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.plot.plot_spectrogram" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="wyrm.plot.plot_tenten">
<code class="descclassname">wyrm.plot.</code><code class="descname">plot_tenten</code><span class="sig-paren">(</span><em>data</em>, <em>highlights=None</em>, <em>hcolors=None</em>, <em>legend=False</em>, <em>scale=True</em>, <em>reg_chans=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/plot.html#plot_tenten"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.plot.plot_tenten" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots channels on a grid system.</p>
<p>Iterates over every channel in the data structure. If the
channelname matches a channel in the tenten-system it will be
plotted in a grid of rectangles. The grid is structured like the
tenten-system itself, but in a simplified manner. The rows, in which
channels appear, are predetermined, the channels are ordered
automatically within their respective row. Areas to highlight can be
specified, those areas will be marked with colors in every
timeinterval plot.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data"><em>wyrm.types.Data</em></a>) &#8211; Data object containing the data to plot.</li>
<li><strong>highlights</strong> (<em>[[int, int)]</em>) &#8211; List of tuples containing the start point (included) and end
point (excluded) of each area to be highlighted (default: None).</li>
<li><strong>hcolors</strong> (<em>[colors], optional</em>) &#8211; A list of colors to use for the highlight areas (default: None).</li>
<li><strong>legend</strong> (<em>Boolean, optional</em>) &#8211; Flag to switch plotting of the legend on or off (default: True).</li>
<li><strong>scale</strong> (<em>Boolean, optional</em>) &#8211; Flag to switch plotting of a scale in the top right corner of
the grid (default: True)</li>
<li><strong>reg_chans</strong> (<em>[regular expressions]</em>) &#8211; A list of regular expressions. The plot will be limited to those
channels matching the regular expressions.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Returns the plotted timeinterval axes as a list of
Matplotlib.Axes and the plotted scale as a single
Matplotlib.Axes.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">[Matplotlib.Axes], Matplotlib.Axes</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Plotting of all channels within a Data object</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">plot_tenten</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p>Plotting of all channels with a highlighted area</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">plot_tenten</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">highlights</span><span class="o">=</span><span class="p">[[</span><span class="mi">200</span><span class="p">,</span> <span class="mi">400</span><span class="p">]])</span>
</pre></div>
</div>
<p>Plotting of all channels beginning with &#8216;A&#8217;</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">plot_tenten</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">reg_chans</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;A.*&#39;</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.plot.plot_timeinterval">
<code class="descclassname">wyrm.plot.</code><code class="descname">plot_timeinterval</code><span class="sig-paren">(</span><em>data</em>, <em>r_square=None</em>, <em>highlights=None</em>, <em>hcolors=None</em>, <em>legend=True</em>, <em>reg_chans=None</em>, <em>position=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/plot.html#plot_timeinterval"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.plot.plot_timeinterval" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots a simple time interval.</p>
<p>Plots all channels of either continuous data or the mean of epoched
data into a single timeinterval plot.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data"><em>wyrm.types.Data</em></a>) &#8211; Data object containing the data to plot.</li>
<li><strong>r_square</strong> (<em>[values], optional</em>) &#8211; List containing r_squared values to be plotted beneath the main
plot (default: None).</li>
<li><strong>highlights</strong> (<em>[[int, int)]</em>) &#8211; List of tuples containing the start point (included) and end
point (excluded) of each area to be highlighted (default: None).</li>
<li><strong>hcolors</strong> (<em>[colors], optional</em>) &#8211; A list of colors to use for the highlights areas (default:
None).</li>
<li><strong>legend</strong> (<em>Boolean, optional</em>) &#8211; Flag to switch plotting of the legend on or off (default: True).</li>
<li><strong>reg_chans</strong> (<em>[regular expression], optional</em>) &#8211; A list of regular expressions. The plot will be limited to those
channels matching the regular expressions. (default: None).</li>
<li><strong>position</strong> (<em>[x, y, width, height], optional</em>) &#8211; A Rectangle that limits the plot to its boundaries (default:
None).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The Matplotlib.Axes corresponding to the plotted timeinterval
and, if provided, the Axes corresponding to r_squared values.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Matplotlib.Axes or (Matplotlib.Axes, Matplotlib.Axes)</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Plots all channels contained in data with a legend.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">plot_timeinterval</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p>Same as above, but without the legend.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">plot_timeinterval</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">legend</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Adds r-square values to the plot.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">plot_timeinterval</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">r_square</span><span class="o">=</span><span class="p">[</span><span class="n">values</span><span class="p">])</span>
</pre></div>
</div>
<p>Adds a highlighted area to the plot.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">plot_timeinterval</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">highlights</span><span class="o">=</span><span class="p">[[</span><span class="mi">200</span><span class="p">,</span> <span class="mi">400</span><span class="p">]])</span>
</pre></div>
</div>
<p>To specify the colors of the highlighted areas use &#8216;hcolors&#8217;.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">plot_timeinterval</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">highlights</span><span class="o">=</span><span class="p">[[</span><span class="mi">200</span><span class="p">,</span> <span class="mi">400</span><span class="p">]],</span> <span class="n">hcolors</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;red&#39;</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.plot.set_highlights">
<code class="descclassname">wyrm.plot.</code><code class="descname">set_highlights</code><span class="sig-paren">(</span><em>highlights</em>, <em>hcolors=None</em>, <em>set_axes=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/plot.html#set_highlights"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.plot.set_highlights" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets highlights in form of vertical boxes to axes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>highlights</strong> (<em>[(start, end)]</em>) &#8211; List of tuples containing the start point (included) and end
point (excluded) of each area to be highlighted.</li>
<li><strong>hcolors</strong> (<em>[colors], optional</em>) &#8211; A list of colors to use for the highlight areas (e.g. &#8216;b&#8217;,
&#8216;#eeefff&#8217; or [R, G, B] for R, G, B = [0..1]. If left as None the
colors blue, gree, red, cyan, magenta and yellow are used.</li>
<li><strong>set_axes</strong> (<em>[matplotlib.axes.Axes], optional</em>) &#8211; List of axes to highlights (default: None, all axes of the
current figure will be highlighted).</li>
<li><strong>Examples</strong> &#8211; </li>
<li><strong>---------</strong> &#8211; </li>
<li><strong>create two highlighted areas in all axes of the currently active</strong> (<em>To</em>) &#8211; </li>
<li><strong>The first area from 200ms - 300ms in blue and the second</strong> (<em>figure.</em>) &#8211; </li>
<li><strong>from 500ms - 600ms in green.</strong> (<em>area</em>) &#8211; </li>
<li><strong>set_highlights([[200, 300], [500, 600]])</strong> (<em>&gt;&gt;&gt;</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-wyrm.processing">
<span id="wyrm-processing-module"></span><h2>wyrm.processing module<a class="headerlink" href="#module-wyrm.processing" title="Permalink to this headline">¶</a></h2>
<p>Processing toolbox methods.</p>
<p>This module contains the processing methods.</p>
<dl class="function">
<dt id="wyrm.processing.append">
<code class="descclassname">wyrm.processing.</code><code class="descname">append</code><span class="sig-paren">(</span><em>dat</em>, <em>dat2</em>, <em>axis=0</em>, <em>extra=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/processing.html#append"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Append <code class="docutils literal"><span class="pre">dat2</span></code> to <code class="docutils literal"><span class="pre">dat</span></code>.</p>
<p>This method creates a copy of <code class="docutils literal"><span class="pre">dat</span></code> (with all attributes),
concatenates <code class="docutils literal"><span class="pre">dat.data</span></code> and <code class="docutils literal"><span class="pre">dat2.data</span></code> along <code class="docutils literal"><span class="pre">axis</span></code> as well
as <code class="docutils literal"><span class="pre">dat.axes[axis]</span></code> and <code class="docutils literal"><span class="pre">dat2.axes[axis]</span></code>. If present, it will
concatenate the attributes in <code class="docutils literal"><span class="pre">extra</span></code> as well and return the
result.</p>
<p>It also performs checks if the dimensions and lengths of <code class="docutils literal"><span class="pre">data</span></code>
and <code class="docutils literal"><span class="pre">axes</span></code> match and test if <code class="docutils literal"><span class="pre">units</span></code> and <code class="docutils literal"><span class="pre">names</span></code> are equal.</p>
<p>Since <code class="docutils literal"><span class="pre">append</span></code> cannot know how to deal with the various attributes
<code class="docutils literal"><span class="pre">dat</span></code> and <code class="docutils literal"><span class="pre">dat2</span></code> might have, it only copies the attributes of
<code class="docutils literal"><span class="pre">dat</span></code> and deals with the attributes it knows about, namely:
<code class="docutils literal"><span class="pre">data</span></code>, <code class="docutils literal"><span class="pre">axes</span></code>, <code class="docutils literal"><span class="pre">names</span></code>, and <code class="docutils literal"><span class="pre">units</span></code>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This method is really low level and stupid. It does not know
about markers or timeaxes, etc. it just appends two data
objects. If you want to append continuous or epoched data
consider using <a class="reference internal" href="#wyrm.processing.append_cnt" title="wyrm.processing.append_cnt"><code class="xref py py-func docutils literal"><span class="pre">append_cnt()</span></code></a> and <a class="reference internal" href="#wyrm.processing.append_epo" title="wyrm.processing.append_epo"><code class="xref py py-func docutils literal"><span class="pre">append_epo()</span></code></a>.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dat2</strong> (<em>dat,</em>) &#8211; </li>
<li><strong>axis</strong> (<em>int, optional</em>) &#8211; the axis along which to concatenate. The default axis (0) does
the right thing for continuous and epoched data as it
concatenates along the time- or the class-axis respectively.</li>
<li><strong>extra</strong> (<em>list of strings, optional</em>) &#8211; a list of attributes in <code class="docutils literal"><span class="pre">dat</span></code> and <code class="docutils literal"><span class="pre">dat2</span></code> to concatenate as
well. Currently the attributes must have the types <code class="docutils literal"><span class="pre">list</span></code> or
<code class="docutils literal"><span class="pre">ndarray</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dat</strong> &#8211;
a copy of <code class="docutils literal"><span class="pre">dat</span></code> with <code class="docutils literal"><span class="pre">dat2</span></code> appended</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data">Data</a></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last">
<li><p class="first"><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> &#8211;
if one of the following is true:</p>
<blockquote>
<div><ul class="simple">
<li>the dimensions of <code class="docutils literal"><span class="pre">.data</span></code> do not match</li>
<li><code class="docutils literal"><span class="pre">names</span></code> are not equal</li>
<li><code class="docutils literal"><span class="pre">units</span></code> are not equal</li>
<li><code class="docutils literal"><span class="pre">data.shape[i]</span></code> are not equal for all i except <code class="docutils literal"><span class="pre">i</span> <span class="pre">==</span> <span class="pre">axis</span></code></li>
<li><code class="docutils literal"><span class="pre">axes[i]</span></code> are not equal for all i except <code class="docutils literal"><span class="pre">i</span> <span class="pre">==</span> <span class="pre">axis</span></code></li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code> &#8211;
if one of the following is true:</p>
<blockquote>
<div><ul class="simple">
<li>if one of the attributes in <code class="docutils literal"><span class="pre">extra</span></code> does not have the same
type in <code class="docutils literal"><span class="pre">dat</span></code> and <code class="docutils literal"><span class="pre">dat2</span></code></li>
<li>if one of the attributes in <code class="docutils literal"><span class="pre">extra</span></code> has an unsupported type</li>
</ul>
</div></blockquote>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># concatenate two continuous data objects, and their markers,</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># please note how the resulting marker is not correct, just</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># appended</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnt</span><span class="o">.</span><span class="n">markers</span>
<span class="go">[[0, &#39;a&#39;], [10, &#39;b&#39;]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnt2</span><span class="o">.</span><span class="n">markers</span>
<span class="go">[[20, &#39;c&#39;], [30, &#39;d&#39;]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnt</span> <span class="o">=</span> <span class="n">append</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">cnt2</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;markers&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnt</span><span class="o">.</span><span class="n">markers</span>
<span class="go">[[0, &#39;a&#39;], [10, &#39;b&#39;], [20, &#39;c&#39;], [30, &#39;d&#39;]]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#wyrm.processing.append_cnt" title="wyrm.processing.append_cnt"><code class="xref py py-func docutils literal"><span class="pre">append_cnt()</span></code></a>, <a class="reference internal" href="#wyrm.processing.append_epo" title="wyrm.processing.append_epo"><code class="xref py py-func docutils literal"><span class="pre">append_epo()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.append_cnt">
<code class="descclassname">wyrm.processing.</code><code class="descname">append_cnt</code><span class="sig-paren">(</span><em>dat</em>, <em>dat2</em>, <em>timeaxis=-2</em>, <em>extra=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/processing.html#append_cnt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.append_cnt" title="Permalink to this definition">¶</a></dt>
<dd><p>Append two continuous data objects.</p>
<p>This method uses <a class="reference internal" href="#wyrm.processing.append" title="wyrm.processing.append"><code class="xref py py-func docutils literal"><span class="pre">append()</span></code></a> to append to continuous data
objects. It also takes care that the resulting continuous will have
a correct <code class="docutils literal"><span class="pre">.axes[timeaxis]</span></code>. For that it uses the <code class="docutils literal"><span class="pre">.fs</span></code>
attribute and the length of the data to recalculate the timeaxis.</p>
<p>If both <code class="docutils literal"><span class="pre">dat</span></code> and <code class="docutils literal"><span class="pre">dat2</span></code> have the <code class="docutils literal"><span class="pre">markers</span></code> attribute, the
markers will be treated properly (i.e. by moving the markers of
<code class="docutils literal"><span class="pre">dat2</span></code> by <code class="docutils literal"><span class="pre">dat</span></code> milliseconds to the right.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dat2</strong> (<em>dat,</em>) &#8211; </li>
<li><strong>timeaxis</strong> (<em>int, optional</em>) &#8211; </li>
<li><strong>extra</strong> (<em>list of strings, optional</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dat</strong> &#8211;
the resulting combination of <code class="docutils literal"><span class="pre">dat</span></code> and <code class="docutils literal"><span class="pre">dat2</span></code></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data">Data</a></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> &#8211;
if at least one of the <code class="docutils literal"><span class="pre">Data</span></code> parameters has not the <code class="docutils literal"><span class="pre">.fs</span></code>
attribute or if the <code class="docutils literal"><span class="pre">.fs</span></code> attributes are not equal.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#wyrm.processing.append" title="wyrm.processing.append"><code class="xref py py-func docutils literal"><span class="pre">append()</span></code></a>, <a class="reference internal" href="#wyrm.processing.append_epo" title="wyrm.processing.append_epo"><code class="xref py py-func docutils literal"><span class="pre">append_epo()</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">cnt</span><span class="o">.</span><span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">[0, 1, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnt2</span><span class="o">.</span><span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">[0, 1, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnt</span><span class="o">.</span><span class="n">fs</span>
<span class="go">1000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnt</span> <span class="o">=</span> <span class="n">append_cnt</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">cnt2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnt</span><span class="o">.</span><span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">[0, 1, 2, 3, 4, 5]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.append_epo">
<code class="descclassname">wyrm.processing.</code><code class="descname">append_epo</code><span class="sig-paren">(</span><em>dat</em>, <em>dat2</em>, <em>classaxis=0</em>, <em>extra=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/processing.html#append_epo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.append_epo" title="Permalink to this definition">¶</a></dt>
<dd><p>Append two epoched data objects.</p>
<p>This method just calls <a class="reference internal" href="#wyrm.processing.append" title="wyrm.processing.append"><code class="xref py py-func docutils literal"><span class="pre">append()</span></code></a>. In addition to the errors
<a class="reference internal" href="#wyrm.processing.append" title="wyrm.processing.append"><code class="xref py py-func docutils literal"><span class="pre">append()</span></code></a> might throw, it will raise an error if the
<code class="docutils literal"><span class="pre">class_names</span></code> are not equal if present in both objects.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dat2</strong> (<em>dat,</em>) &#8211; </li>
<li><strong>classaxis</strong> (<em>int, optional</em>) &#8211; </li>
<li><strong>extra</strong> (<em>list of strings, optional</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dat</strong></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data">Data</a></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code> &#8211;
if both objects have a <code class="docutils literal"><span class="pre">class_names</span></code> attribute, they must be
equal</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#wyrm.processing.append" title="wyrm.processing.append"><code class="xref py py-func docutils literal"><span class="pre">append()</span></code></a>, <a class="reference internal" href="#wyrm.processing.append_cnt" title="wyrm.processing.append_cnt"><code class="xref py py-func docutils literal"><span class="pre">append_cnt()</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">epo</span> <span class="o">=</span> <span class="n">append_epo</span><span class="p">(</span><span class="n">epo</span><span class="p">,</span> <span class="n">epo2</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.apply_csp">
<code class="descclassname">wyrm.processing.</code><code class="descname">apply_csp</code><span class="sig-paren">(</span><em>epo, filt, columns=[0, -1]</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/processing.html#apply_csp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.apply_csp" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the CSP filter.</p>
<p>Apply the spacial CSP filter to the epoched data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>epo</strong> (epoched <code class="docutils literal"><span class="pre">Data</span></code> object) &#8211; this method relies on the <code class="docutils literal"><span class="pre">epo</span></code> to have three dimensions in
the following order: class, time, channel</li>
<li><strong>filt</strong> (<em>2d array</em>) &#8211; the CSP filter (i.e. the <code class="docutils literal"><span class="pre">v</span></code> return value from
<a class="reference internal" href="#wyrm.processing.calculate_csp" title="wyrm.processing.calculate_csp"><code class="xref py py-func docutils literal"><span class="pre">calculate_csp()</span></code></a>)</li>
<li><strong>columns</strong> (<em>array of ints, optional</em>) &#8211; the columns of the filter to use. The default is the first and
the last one.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>epo</strong> &#8211;
The channels from the original have been replaced with the new
virtual CSP channels.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">epoched <code class="docutils literal"><span class="pre">Data</span></code> object</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">w</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">calculate_csp</span><span class="p">(</span><span class="n">epo</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">epo</span> <span class="o">=</span> <span class="n">apply_csp</span><span class="p">(</span><span class="n">epo</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#wyrm.processing.calculate_csp" title="wyrm.processing.calculate_csp"><code class="xref py py-func docutils literal"><span class="pre">calculate_csp()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.calculate_cca">
<code class="descclassname">wyrm.processing.</code><code class="descname">calculate_cca</code><span class="sig-paren">(</span><em>dat_x</em>, <em>dat_y</em>, <em>timeaxis=-2</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/processing.html#calculate_cca"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.calculate_cca" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the Canonical Correlation Analysis (CCA).</p>
<p>This method calculates the canonical correlation coefficient and
corresponding weights which maximize a correlation coefficient
between linear combinations of the two specified multivariable
signals.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dat_y</strong> (<em>dat_x,</em>) &#8211; these data should have the same length on the time axis.</li>
<li><strong>timeaxis</strong> (<em>int, optional</em>) &#8211; the index of the time axis in <code class="docutils literal"><span class="pre">dat_x</span></code> and <code class="docutils literal"><span class="pre">dat_y</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul class="simple">
<li><strong>rho</strong> (<em>float</em>) &#8211;
the canonical correlation coefficient.</li>
<li><strong>w_x, w_y</strong> (<em>1d array</em>) &#8211;
the weights for mapping from the specified multivariable signals
to canonical variables.</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> &#8211;
If:</p>
<blockquote class="last">
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">dat_x</span></code> and <code class="docutils literal"><span class="pre">dat_y</span></code> is not continuous Data object</li>
<li>the length of <code class="docutils literal"><span class="pre">dat_x</span></code> and <code class="docutils literal"><span class="pre">dat_y</span></code> is different on the
<code class="docutils literal"><span class="pre">timeaxis</span></code></li>
</ul>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Calculate the CCA of the specified multivariable signals.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rho</span><span class="p">,</span> <span class="n">w_x</span><span class="p">,</span> <span class="n">w_y</span> <span class="o">=</span> <span class="n">calculate_cca</span><span class="p">(</span><span class="n">dat_x</span><span class="p">,</span> <span class="n">dat_y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Calculate canonical variables via obtained weights</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cv_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dat_x</span><span class="p">,</span> <span class="n">w_x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cv_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dat_y</span><span class="p">,</span> <span class="n">w_y</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">References</p>
<p><a class="reference external" href="http://en.wikipedia.org/wiki/Canonical_correlation">http://en.wikipedia.org/wiki/Canonical_correlation</a></p>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.calculate_classwise_average">
<code class="descclassname">wyrm.processing.</code><code class="descname">calculate_classwise_average</code><span class="sig-paren">(</span><em>dat</em>, <em>classaxis=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/processing.html#calculate_classwise_average"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.calculate_classwise_average" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the classwise average.</p>
<p>This method calculates the average continuous per class for all
classes defined in the <code class="docutils literal"><span class="pre">dat</span></code>. In other words, if you have two
different classes, with many continuous data per class, this method
will calculate the average time course for each class and channel.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dat</strong> (<a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data"><em>Data</em></a>) &#8211; an epoched Data object with a <code class="docutils literal"><span class="pre">.class_names</span></code> attribute.</li>
<li><strong>classaxis</strong> (<em>int, optional</em>) &#8211; the axis along which to calculate the average</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dat</strong> &#8211;
copy of <code class="docutils literal"><span class="pre">dat</span></code> a witht the <code class="docutils literal"><span class="pre">classaxis</span></code> dimension reduced to
the number of different classes.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data">Data</a></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> &#8211;
if the <code class="docutils literal"><span class="pre">dat</span></code> has no <code class="docutils literal"><span class="pre">.class_names</span></code> attribute.</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Split existing continuous data into two classes and calculate the
average for each class.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mrk_def</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;std&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s">&#39;S </span><span class="si">%2i</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">)],</span>
<span class="gp">... </span>           <span class="s">&#39;dev&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s">&#39;S </span><span class="si">%2i</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">17</span><span class="p">)]</span>
<span class="gp">... </span>          <span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">epo</span> <span class="o">=</span> <span class="n">misc</span><span class="o">.</span><span class="n">segment_dat</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">mrk_def</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">660</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">avg_epo</span> <span class="o">=</span> <span class="n">calculate_classwise_average</span><span class="p">(</span><span class="n">epo</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">(</span><span class="n">avg_epo</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">(</span><span class="n">avg_epo</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.calculate_csp">
<code class="descclassname">wyrm.processing.</code><code class="descname">calculate_csp</code><span class="sig-paren">(</span><em>epo</em>, <em>classes=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/processing.html#calculate_csp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.calculate_csp" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the Common Spatial Pattern (CSP) for two classes.</p>
<p>This method calculates the CSP and the corresponding filters. Use
the columns of the patterns and filters.</p>
<p class="rubric">Examples</p>
<p>Calculate the CSP for the first two classes:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">w</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">calculate_csp</span><span class="p">(</span><span class="n">epo</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Apply the first two and the last two columns of the sorted</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># filter to the data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filtered</span> <span class="o">=</span> <span class="n">apply_csp</span><span class="p">(</span><span class="n">epo</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># You&#39;ll probably want to get the log-variance along the time</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># axis, this should result in four numbers (one for each</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># channel)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filtered</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">filtered</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
<p>Select two classes manually:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">w</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">calculate_csp</span><span class="p">(</span><span class="n">epo</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>epo</strong> (<em>epoched Data object</em>) &#8211; this method relies on the <code class="docutils literal"><span class="pre">epo</span></code> to have three dimensions in
the following order: class, time, channel</li>
<li><strong>classes</strong> (<em>list of two ints, optional</em>) &#8211; If <code class="docutils literal"><span class="pre">None</span></code> the first two different class indices found in
<code class="docutils literal"><span class="pre">epo.axes[0]</span></code> are chosen automatically otherwise the class
indices can be manually chosen by setting <code class="docutils literal"><span class="pre">classes</span></code></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul class="simple">
<li><strong>v</strong> (<em>2d array</em>) &#8211;
the sorted spacial filters</li>
<li><strong>a</strong> (<em>2d array</em>) &#8211;
the sorted spacial patterns. Column i of a represents the
pattern of the filter in column i of v.</li>
<li><strong>d</strong> (<em>1d array</em>) &#8211;
the variances of the components</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> &#8211;
If:</p>
<blockquote class="last">
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">classes</span></code> is not <code class="docutils literal"><span class="pre">None</span></code> and has less than two elements</li>
<li><code class="docutils literal"><span class="pre">classes</span></code> is not <code class="docutils literal"><span class="pre">None</span></code> and the first two elements are
not found in the <code class="docutils literal"><span class="pre">epo</span></code></li>
<li><code class="docutils literal"><span class="pre">classes</span></code> is <code class="docutils literal"><span class="pre">None</span></code> but there are less than two
different classes in the <code class="docutils literal"><span class="pre">epo</span></code></li>
</ul>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#wyrm.processing.apply_csp" title="wyrm.processing.apply_csp"><code class="xref py py-func docutils literal"><span class="pre">apply_csp()</span></code></a>, <a class="reference internal" href="#wyrm.processing.calculate_spoc" title="wyrm.processing.calculate_spoc"><code class="xref py py-func docutils literal"><span class="pre">calculate_spoc()</span></code></a></p>
</div>
<p class="rubric">References</p>
<p><a class="reference external" href="http://en.wikipedia.org/wiki/Common_spatial_pattern">http://en.wikipedia.org/wiki/Common_spatial_pattern</a></p>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.calculate_signed_r_square">
<code class="descclassname">wyrm.processing.</code><code class="descname">calculate_signed_r_square</code><span class="sig-paren">(</span><em>dat</em>, <em>classaxis=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/processing.html#calculate_signed_r_square"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.calculate_signed_r_square" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the signed r**2 values.</p>
<p>This method calculates the signed r**2 values over the epochs of the
<code class="docutils literal"><span class="pre">dat</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dat</strong> (<a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data"><em>Data</em></a>) &#8211; epoched data</li>
<li><strong>classaxis</strong> (<em>int, optional</em>) &#8211; the axis to be treatet as the classaxis</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>signed_r_square</strong> &#8211;
the signed r**2 values, signed_r_square has one axis less than
the <code class="docutils literal"><span class="pre">dat</span></code> parameter, the <code class="docutils literal"><span class="pre">classaxis</span></code> has been removed</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">ndarray</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(400, 100, 64)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">calculate_signed_r_square</span><span class="p">(</span><span class="n">dat</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(100, 64)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.calculate_spoc">
<code class="descclassname">wyrm.processing.</code><code class="descname">calculate_spoc</code><span class="sig-paren">(</span><em>epo</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/processing.html#calculate_spoc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.calculate_spoc" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute source power co-modulation analysis (SPoC)</p>
<p>Computes spatial filters that optimize the co-modulation (here
covariance) between the epoch-wise variance (as a proxy for spectral
power) and a given target signal.</p>
<p>This SPoc function returns a full set of components (i.e. filters
and patterns) of which the first component maximizes the
co-modulation (i.e. positive covariance) and the last component
minimizes it (i.e. maximizes negative covariance).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Since the covariance is optimized, it may be affected by
outliers in the data (i.e. trials/epochs with very large
variance that is due to artifacts). Please remove be sure to
remove these epochs if possible before calling this function!</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>epo</strong> (<em>epoched Data oject</em>) &#8211; this method relies on the <code class="docutils literal"><span class="pre">epo</span></code> to have three dimensions in
the following order: class, time, channel. The data in epo
should be band-pass filtered for the frequency band of interest.
The values of the target variable (i.e. <code class="docutils literal"><span class="pre">epo.axes[0]</span></code>) must be
present in epo.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><ul class="simple">
<li><strong>v</strong> (<em>2d array</em>) &#8211;
The spatial filters optimized by the <code class="docutils literal"><span class="pre">SPoC_lambda</span></code> algorithm.
Each column in the matrix is a filter.</li>
<li><strong>a</strong> (<em>2d array</em>) &#8211;
The spatial activation patterns that correspond to the filters
in <code class="docutils literal"><span class="pre">v</span></code>. Each column is a spatial pattern. when visualizing the
SPoC components as scalp maps, plot the spatial patterns and not
the filters. See also <a class="reference internal" href="#haufe2014" id="id3">[haufe2014]</a>.</li>
<li><strong>d</strong> (<em>1d array</em>) &#8211;
The lambda values that correspond to the filters/patterns in
<code class="docutils literal"><span class="pre">v</span></code> and <code class="docutils literal"><span class="pre">a</span></code>, sorted from largest (positive covariance) to
smallest (negative covariance).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Split data in training and test set</p>
<p>Calculate SPoC:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">w</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">calculate_spoc</span><span class="p">(</span><span class="n">epo</span><span class="p">)</span>
</pre></div>
</div>
<p>Identify the components with strongest co-modulation by checking the
covariance values stored in <code class="docutils literal"><span class="pre">d</span></code>. If there is positive covariance
with the target variable it will be the first, otherwise the last:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="n">w</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>Apply the filter(s) to the test data:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">filtered</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>SPoC assumes that there is a linear relationship between a measured
target signal and the dynamics of the spectral power of an
oscillatory source that is hidden in the data. The target signal my
be a stimulus property (e.g. intensity, frequency, color, ...), a
behavioral measure (e.g. reaction times, ratings, ...) , or any
other uni-variate signal of interest. The time-course of spectral
power of the oscillatory source signal is approximated by variance
across small time segments (epochs). Thus, if the power of a
specific frequency band is investigated, the input signals must be
band-passed filtered before they are segmented into epochs and given
to this function. This method implements <code class="docutils literal"><span class="pre">SPoC_lambda</span></code>, presented
in <a class="reference internal" href="#daehne2014" id="id4">[daehne2014]</a>. Thus, source activity is extracted from the input
data via spatial filtering. The spatial filters are optimized such
that the epoch-wise variance maximally covaries with the given
target signal <code class="docutils literal"><span class="pre">z</span></code>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#wyrm.processing.calculate_csp" title="wyrm.processing.calculate_csp"><code class="xref py py-func docutils literal"><span class="pre">calculate_csp()</span></code></a></p>
</div>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="daehne2014" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[daehne2014]</a></td><td>S. Dähne, F. C. Meinecke, S. Haufe, J. Höhne, M.
Tangermann, K. R. Müller, V. V. Nikulin &#8220;SPoC: a novel framework
for relating the amplitude of neuronal oscillations to
behaviorally relevant parameters&#8221;, NeuroImage, 86(0):111-122,
2014</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="haufe2014" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[haufe2014]</a></td><td>S. Haufe, F. Meinecke, K. Görgen, S. Dähne, J.
Haynes, B. Blankertz, F. Biessmann, &#8220;On the interpretation of
weight vectors of linear models in multivariate neuroimaging&#8221;,
NeuroImage, 87:96-110, 2014</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.clear_markers">
<code class="descclassname">wyrm.processing.</code><code class="descname">clear_markers</code><span class="sig-paren">(</span><em>dat</em>, <em>timeaxis=-2</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/processing.html#clear_markers"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.clear_markers" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove markers that are outside of the <code class="docutils literal"><span class="pre">dat</span></code> time interval.</p>
<p>This method removes the markers that are out of the time interval
described in the <code class="docutils literal"><span class="pre">dat</span></code> object.</p>
<p>If the <code class="docutils literal"><span class="pre">dat</span></code> object has not <code class="docutils literal"><span class="pre">markers</span></code> attribute or the markers
are empty, simply a copy of <code class="docutils literal"><span class="pre">dat</span></code> is returned.</p>
<p>If <code class="docutils literal"><span class="pre">dat.data</span></code> is empty, but has markers, all markers are removed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dat</strong> (<a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data"><em>Data</em></a>) &#8211; </li>
<li><strong>timeaxis</strong> (<em>int, optional</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dat</strong> &#8211;
a copy of the Data object, with the respective markers removed</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data">Data</a></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> &#8211;
if the given <code class="docutils literal"><span class="pre">dat</span></code> has not <code class="docutils literal"><span class="pre">fs</span></code> attribute</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">array([-5., -4., -3., -2., -1.,  0.,  1.,  2.,  3.,  4.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">fs</span>
<span class="go">1000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">markers</span>
<span class="go">[[-6, &#39;a&#39;], [-5, &#39;b&#39;], [0, &#39;c&#39;], [4.9999, &#39;d&#39;], [5, &#39;e&#39;]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="n">clear_markers</span><span class="p">(</span><span class="n">dat</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">markers</span>
<span class="go">[[-5, &#39;b&#39;], [0, &#39;c&#39;], [4.9999, &#39;d&#39;]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.correct_for_baseline">
<code class="descclassname">wyrm.processing.</code><code class="descname">correct_for_baseline</code><span class="sig-paren">(</span><em>dat</em>, <em>ival</em>, <em>timeaxis=-2</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/processing.html#correct_for_baseline"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.correct_for_baseline" title="Permalink to this definition">¶</a></dt>
<dd><p>Subtract the baseline.</p>
<p>For each epoch and channel in the given dat, this method calculates
the average value for the given interval and subtracts this value
from the channel data within this epoch and channel.</p>
<p>This method generalizes to dats with more than 3 dimensions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dat</strong> (<em>Dat</em>) &#8211; </li>
<li><strong>ival</strong> (<em>array of two floats</em>) &#8211; the start and stop borders in milli seconds. the left border is
included, the right border is not: <code class="docutils literal"><span class="pre">[start,</span> <span class="pre">stop)</span></code>.
<code class="docutils literal"><span class="pre">ival[0]</span></code> must fit into <code class="docutils literal"><span class="pre">dat.axes[timeaxis]</span></code> and
<code class="docutils literal"><span class="pre">ival[0]</span> <span class="pre">&lt;=</span> <span class="pre">ival[1]</span></code>.</li>
<li><strong>timeaxis</strong> (<em>int, optional</em>) &#8211; the axis along which to correct for the baseline</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dat</strong> &#8211;
a copy of <code class="docutils literal"><span class="pre">dat</span></code> with the averages of the intervals subtracted.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Dat</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Remove the baselines for the interval <code class="docutils literal"><span class="pre">[100,</span> <span class="pre">0)</span></code></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="n">correct_for_baseline</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>The Algorithm calculates the average(s) along the <code class="docutils literal"><span class="pre">timeaxis</span></code> within
the given interval. The resulting array has one dimension less
than the original one (the elements on <code class="docutils literal"><span class="pre">timeaxis</span></code> where reduced).</p>
<p>The resulting avgarray is then subtracted from the original data. To
match the shape, a new axis is created on <code class="docutils literal"><span class="pre">timeaxis</span></code> of avgarray.
And the shapes are then matched via numpy&#8217;s broadcasting.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> &#8211;
If the left border of <code class="docutils literal"><span class="pre">ival</span></code> is outside of
<code class="docutils literal"><span class="pre">dat.axes[timeaxis]</span></code> or if <code class="docutils literal"><span class="pre">ival[1]</span> <span class="pre">&lt;</span> <span class="pre">ival[0]</span></code>.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-func docutils literal"><span class="pre">numpy.average()</span></code>, <code class="xref py py-func docutils literal"><span class="pre">numpy.expand_dims()</span></code></p>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.create_feature_vectors">
<code class="descclassname">wyrm.processing.</code><code class="descname">create_feature_vectors</code><span class="sig-paren">(</span><em>dat</em>, <em>classaxis=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/processing.html#create_feature_vectors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.create_feature_vectors" title="Permalink to this definition">¶</a></dt>
<dd><p>Create feature vectors from epoched data.</p>
<p>This method flattens a <code class="docutils literal"><span class="pre">Data</span></code> objects down to 2 dimensions: the
first one for the classes and the second for the feature vectors.
All surplus dimensions of the <code class="docutils literal"><span class="pre">dat</span></code> argument are clashed into the
appropriate class.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dat</strong> (<a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data"><em>Data</em></a>) &#8211; </li>
<li><strong>classaxis</strong> (<em>int, optional</em>) &#8211; the index of the class axis</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dat</strong> &#8211;
a copy of <code class="docutils literal"><span class="pre">dat</span></code> with reshaped to 2 dimensions and with the
classaxis moved to dimension 0</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data">Data</a></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(300, 2, 64)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="n">create_feature_vectors</span><span class="p">(</span><span class="n">dat</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(300, 128)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.filtfilt">
<code class="descclassname">wyrm.processing.</code><code class="descname">filtfilt</code><span class="sig-paren">(</span><em>dat</em>, <em>b</em>, <em>a</em>, <em>timeaxis=-2</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/processing.html#filtfilt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.filtfilt" title="Permalink to this definition">¶</a></dt>
<dd><p>A forward-backward filter.</p>
<p>Filter data twice, once forward and once backwards, using the filter
defined by the filter coefficients.</p>
<p>This method mainly delegates the call to
<code class="xref py py-func docutils literal"><span class="pre">scipy.signal.filtfilt()</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dat</strong> (<a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data"><em>Data</em></a>) &#8211; the data to be filtered</li>
<li><strong>b</strong> (<em>1-d array</em>) &#8211; the numerator coefficient vector</li>
<li><strong>a</strong> (<em>1-d array</em>) &#8211; the denominator coefficient vector</li>
<li><strong>timeaxis</strong> (<em>int, optional</em>) &#8211; the axes in <code class="docutils literal"><span class="pre">data</span></code> to filter along to</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dat</strong> &#8211;
the filtered output</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data">Data</a></p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#wyrm.processing.lfilter" title="wyrm.processing.lfilter"><code class="xref py py-func docutils literal"><span class="pre">lfilter()</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<p>Generate and use a Butterworth bandpass filter for complete
(off-line data):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># the sampling frequency of our data in Hz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">fs</span>
<span class="go">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># calculate the nyquist frequency</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fn</span> <span class="o">=</span> <span class="n">dat</span><span class="o">.</span><span class="n">fs</span> <span class="o">/</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># the desired low and high frequencies in Hz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f_low</span><span class="p">,</span> <span class="n">f_high</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">13</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># the order of the filter</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">butter_ord</span> <span class="o">=</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># calculate the filter coefficients</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">butter</span><span class="p">(</span><span class="n">butter_ord</span><span class="p">,</span> <span class="p">[</span><span class="n">f_low</span> <span class="o">/</span> <span class="n">fn</span><span class="p">,</span> <span class="n">f_high</span> <span class="o">/</span> <span class="n">fn</span><span class="p">],</span> <span class="n">btype</span><span class="o">=</span><span class="s">&#39;band&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filtered</span> <span class="o">=</span> <span class="n">filtfilt</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.jumping_means">
<code class="descclassname">wyrm.processing.</code><code class="descname">jumping_means</code><span class="sig-paren">(</span><em>dat</em>, <em>ivals</em>, <em>timeaxis=-2</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/processing.html#jumping_means"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.jumping_means" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the jumping means.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dat</strong> (<a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data"><em>Data</em></a>) &#8211; </li>
<li><strong>ivals</strong> (<em>array of [float, float]</em>) &#8211; the intervals for which to calculate the means. Start is
included end is not (like <code class="docutils literal"><span class="pre">[start,</span> <span class="pre">end)</span></code>).</li>
<li><strong>timeaxis</strong> (<em>int, optional</em>) &#8211; the axis along which to calculate the jumping means</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dat</strong> &#8211;
copy of <code class="docutils literal"><span class="pre">dat</span></code> with the jumping means along the <code class="docutils literal"><span class="pre">timeaxis</span></code>.
<code class="docutils literal"><span class="pre">dat.name[timeaxis]</span></code> and <code class="docutils literal"><span class="pre">dat.axes[timeaxis]</span></code> Are modified
too to reflect the intervals used for the data points.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data">Data</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.lda_apply">
<code class="descclassname">wyrm.processing.</code><code class="descname">lda_apply</code><span class="sig-paren">(</span><em>fv</em>, <em>clf</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/processing.html#lda_apply"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.lda_apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply feature vector to LDA classifier.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>fv</strong> (<code class="docutils literal"><span class="pre">Data</span></code> object) &#8211; the feature vector must have a 2 dimensional data, the first
dimension being the class axis.</li>
<li><strong>clf</strong> (<em>(1d array, float)</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> &#8211;
The projection of the data on the hyperplane.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">1d array</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span> <span class="o">=</span> <span class="n">lda_train</span><span class="p">(</span><span class="n">fv_train</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">lda_apply</span><span class="p">(</span><span class="n">fv_test</span><span class="p">,</span> <span class="n">clf</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#wyrm.processing.lda_train" title="wyrm.processing.lda_train"><code class="xref py py-func docutils literal"><span class="pre">lda_train()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.lda_train">
<code class="descclassname">wyrm.processing.</code><code class="descname">lda_train</code><span class="sig-paren">(</span><em>fv</em>, <em>shrink=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/processing.html#lda_train"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.lda_train" title="Permalink to this definition">¶</a></dt>
<dd><p>Train the LDA classifier.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>fv</strong> (<code class="docutils literal"><span class="pre">Data</span></code> object) &#8211; the feature vector must have 2 dimensional data, the first
dimension being the class axis. The unique class labels must be
0 and 1 otherwise a <code class="docutils literal"><span class="pre">ValueError</span></code> will be raised.</li>
<li><strong>shrink</strong> (<em>Boolean, optional</em>) &#8211; use shrinkage</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul class="simple">
<li><strong>w</strong> (<em>1d array</em>)</li>
<li><strong>b</strong> (<em>float</em>)</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code> (<em>if the class labels are not exactly 0s and 1s</em>) &#8211;</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span> <span class="o">=</span> <span class="n">lda_train</span><span class="p">(</span><span class="n">fv_train</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">lda_apply</span><span class="p">(</span><span class="n">fv_test</span><span class="p">,</span> <span class="n">clf</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#wyrm.processing.lda_apply" title="wyrm.processing.lda_apply"><code class="xref py py-func docutils literal"><span class="pre">lda_apply()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.lfilter">
<code class="descclassname">wyrm.processing.</code><code class="descname">lfilter</code><span class="sig-paren">(</span><em>dat</em>, <em>b</em>, <em>a</em>, <em>zi=None</em>, <em>timeaxis=-2</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/processing.html#lfilter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.lfilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter data using the filter defined by the filter coefficients.</p>
<p>This method mainly delegates the call to
<code class="xref py py-func docutils literal"><span class="pre">scipy.signal.lfilter()</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dat</strong> (<a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data"><em>Data</em></a>) &#8211; the data to be filtered</li>
<li><strong>b</strong> (<em>1-d array</em>) &#8211; the numerator coefficient vector</li>
<li><strong>a</strong> (<em>1-d array</em>) &#8211; the denominator coefficient vector</li>
<li><strong>zi</strong> (<em>nd array, optional</em>) &#8211; the initial conditions for the filter delay. If zi is <code class="docutils literal"><span class="pre">None</span></code>
or not given, initial rest is assumed.</li>
<li><strong>timeaxis</strong> (<em>int, optional</em>) &#8211; the axes in <code class="docutils literal"><span class="pre">data</span></code> to filter along to</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dat</strong> &#8211;
the filtered output</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data">Data</a></p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#wyrm.processing.lfilter_zi" title="wyrm.processing.lfilter_zi"><code class="xref py py-func docutils literal"><span class="pre">lfilter_zi()</span></code></a>, <a class="reference internal" href="#wyrm.processing.filtfilt" title="wyrm.processing.filtfilt"><code class="xref py py-func docutils literal"><span class="pre">filtfilt()</span></code></a>, <code class="xref py py-func docutils literal"><span class="pre">scipy.signal.lfilter()</span></code>, <code class="xref py py-func docutils literal"><span class="pre">scipy.signal.butter()</span></code>, <code class="xref py py-func docutils literal"><span class="pre">scipy.signal.butterord()</span></code></p>
</div>
<p class="rubric">Examples</p>
<p>Generate and use a Butterworth bandpass filter for complete
(off-line data):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># the sampling frequency of our data in Hz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">fs</span>
<span class="go">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># calculate the nyquist frequency</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fn</span> <span class="o">=</span> <span class="n">dat</span><span class="o">.</span><span class="n">fs</span> <span class="o">/</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># the desired low and high frequencies in Hz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f_low</span><span class="p">,</span> <span class="n">f_high</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">13</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># the order of the filter</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">butter_ord</span> <span class="o">=</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># calculate the filter coefficients</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">butter</span><span class="p">(</span><span class="n">butter_ord</span><span class="p">,</span> <span class="p">[</span><span class="n">f_low</span> <span class="o">/</span> <span class="n">fn</span><span class="p">,</span> <span class="n">f_high</span> <span class="o">/</span> <span class="n">fn</span><span class="p">],</span> <span class="n">btype</span><span class="o">=</span><span class="s">&#39;band&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filtered</span> <span class="o">=</span> <span class="n">lfilter</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>Similar to the above this time in an on-line setting:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># pre-calculate the filter coefficients and the initial filter</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># state</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">butter</span><span class="p">(</span><span class="n">butter_ord</span><span class="p">,</span> <span class="p">[</span><span class="n">f_low</span> <span class="o">/</span> <span class="n">fn</span><span class="p">,</span> <span class="n">f_high</span> <span class="o">/</span> <span class="n">fn</span><span class="p">],</span> <span class="n">btype</span><span class="o">=</span><span class="s">&#39;band&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">zi</span> <span class="o">=</span> <span class="n">proc</span><span class="o">.</span><span class="n">lfilter_zi</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">CHANNELS</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">data</span><span class="p">,</span> <span class="n">markers</span> <span class="o">=</span> <span class="n">amp</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>
<span class="gp">... </span>    <span class="c"># convert incoming data into ``Data`` object</span>
<span class="gp">... </span>    <span class="n">cnt</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
<span class="gp">... </span>    <span class="c"># filter the data, note how filter now also returns the</span>
<span class="gp">... </span>    <span class="c"># filter state which we feed back into the next call of</span>
<span class="gp">... </span>    <span class="c"># ``filter``</span>
<span class="gp">... </span>    <span class="n">cnt</span><span class="p">,</span> <span class="n">zi</span> <span class="o">=</span> <span class="n">lfilter</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">zi</span><span class="o">=</span><span class="n">zi</span><span class="p">)</span>
<span class="gp">... </span>    <span class="o">...</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.lfilter_zi">
<code class="descclassname">wyrm.processing.</code><code class="descname">lfilter_zi</code><span class="sig-paren">(</span><em>b</em>, <em>a</em>, <em>n=1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/processing.html#lfilter_zi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.lfilter_zi" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute an initial state <code class="docutils literal"><span class="pre">zi</span></code> for the <a class="reference internal" href="#wyrm.processing.lfilter" title="wyrm.processing.lfilter"><code class="xref py py-func docutils literal"><span class="pre">lfilter()</span></code></a> function.</p>
<p>When <code class="docutils literal"><span class="pre">n</span> <span class="pre">==</span> <span class="pre">1</span></code> (default), this method mainly delegates the call to
<code class="xref py py-func docutils literal"><span class="pre">scipy.signal.lfilter_zi()</span></code> and returns the result <code class="docutils literal"><span class="pre">zi</span></code>. If
<code class="docutils literal"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">1</span></code>, <code class="docutils literal"><span class="pre">zi</span></code>  is repeated <code class="docutils literal"><span class="pre">n</span></code> times. This is useful if you
want to filter n-dimensional data like multi channel EEG.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>a</strong> (<em>b,</em>) &#8211; The IIR filter coefficients</li>
<li><strong>n</strong> (<em>int, optional</em>) &#8211; The desired width of the output vector. If <code class="docutils literal"><span class="pre">n</span> <span class="pre">==</span> <span class="pre">1</span></code> the output
is simply the 1d zi vector. For <code class="docutils literal"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">1</span></code>, the zi vector is
repeated <code class="docutils literal"><span class="pre">n</span></code> times.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>zi</strong> &#8211;
The initial state of the filter.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">n-d array</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#wyrm.processing.lfilter" title="wyrm.processing.lfilter"><code class="xref py py-func docutils literal"><span class="pre">lfilter()</span></code></a>, <code class="xref py py-func docutils literal"><span class="pre">scipy.signal.lfilter_zi()</span></code></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># pre-calculate the filter coefficients and the initial filter</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># state</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">butter</span><span class="p">(</span><span class="n">butter_ord</span><span class="p">,</span> <span class="p">[</span><span class="n">f_low</span> <span class="o">/</span> <span class="n">fn</span><span class="p">,</span> <span class="n">f_high</span> <span class="o">/</span> <span class="n">fn</span><span class="p">],</span> <span class="n">btype</span><span class="o">=</span><span class="s">&#39;band&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">zi</span> <span class="o">=</span> <span class="n">proc</span><span class="o">.</span><span class="n">lfilter_zi</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">CHANNELS</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">data</span><span class="p">,</span> <span class="n">markers</span> <span class="o">=</span> <span class="n">amp</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>
<span class="gp">... </span>    <span class="c"># convert incoming data into ``Data`` object</span>
<span class="gp">... </span>    <span class="n">cnt</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
<span class="gp">... </span>    <span class="c"># filter the data, note how filter now also returns the</span>
<span class="gp">... </span>    <span class="c"># filter state which we feed back into the next call of</span>
<span class="gp">... </span>    <span class="c"># ``filter``</span>
<span class="gp">... </span>    <span class="n">cnt</span><span class="p">,</span> <span class="n">zi</span> <span class="o">=</span> <span class="n">lfilter</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">zi</span><span class="o">=</span><span class="n">zi</span><span class="p">)</span>
<span class="gp">... </span>    <span class="o">...</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.logarithm">
<code class="descclassname">wyrm.processing.</code><code class="descname">logarithm</code><span class="sig-paren">(</span><em>dat</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/processing.html#logarithm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.logarithm" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the element wise natural logarithm of <code class="docutils literal"><span class="pre">dat.data</span></code>.</p>
<p>Calling this method is equivalent to calling</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dat</strong> (<a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data"><em>Data</em></a>) &#8211; a Data object</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>dat</strong> &#8211;
a copy of <code class="docutils literal"><span class="pre">dat</span></code> with the element wise natural logarithms of
the values in <code class="docutils literal"><span class="pre">.data</span></code></td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data">Data</a></td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#wyrm.processing.square" title="wyrm.processing.square"><code class="xref py py-func docutils literal"><span class="pre">square()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.rectify_channels">
<code class="descclassname">wyrm.processing.</code><code class="descname">rectify_channels</code><span class="sig-paren">(</span><em>dat</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/processing.html#rectify_channels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.rectify_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the absolute values in <code class="docutils literal"><span class="pre">dat.data</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dat</strong> (<a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data"><em>Data</em></a>) &#8211; </td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>dat</strong> &#8211;
a copy of <code class="docutils literal"><span class="pre">dat</span></code> with all values absolute in <code class="docutils literal"><span class="pre">.data</span></code></td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data">Data</a></td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
<span class="go">0.391987338917</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="n">rectify_channels</span><span class="p">(</span><span class="n">dat</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
<span class="go">22.40234266</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.remove_channels">
<code class="descclassname">wyrm.processing.</code><code class="descname">remove_channels</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/processing.html#remove_channels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.remove_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove channels from data.</p>
<p>This method just calls <a class="reference internal" href="#wyrm.processing.select_channels" title="wyrm.processing.select_channels"><code class="xref py py-func docutils literal"><span class="pre">select_channels()</span></code></a> with the same
parameters and the <code class="docutils literal"><span class="pre">invert</span></code> parameter set to <code class="docutils literal"><span class="pre">True</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>dat</strong> &#8211;
A copy of the dat with the channels removed.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data">Data</a></td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#wyrm.processing.select_channels" title="wyrm.processing.select_channels"><code class="xref py py-func docutils literal"><span class="pre">select_channels()</span></code></a></dt>
<dd>Select Channels</dd>
</dl>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.remove_classes">
<code class="descclassname">wyrm.processing.</code><code class="descname">remove_classes</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/processing.html#remove_classes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.remove_classes" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove classes from an epoched Data object.</p>
<p>This method just calls <a class="reference internal" href="#wyrm.processing.select_epochs" title="wyrm.processing.select_epochs"><code class="xref py py-func docutils literal"><span class="pre">select_epochs()</span></code></a> with the <code class="docutils literal"><span class="pre">inverse</span></code>
parameter set to <code class="docutils literal"><span class="pre">True</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>dat</strong> &#8211;
copy of Data object with the classes removed</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data">Data</a></td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#wyrm.processing.select_classes" title="wyrm.processing.select_classes"><code class="xref py py-func docutils literal"><span class="pre">select_classes()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.remove_epochs">
<code class="descclassname">wyrm.processing.</code><code class="descname">remove_epochs</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/processing.html#remove_epochs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.remove_epochs" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove epochs from an epoched Data object.</p>
<p>This method just calls <a class="reference internal" href="#wyrm.processing.select_epochs" title="wyrm.processing.select_epochs"><code class="xref py py-func docutils literal"><span class="pre">select_epochs()</span></code></a> with the <code class="docutils literal"><span class="pre">inverse</span></code>
paramerter set to <code class="docutils literal"><span class="pre">True</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>dat</strong> &#8211;
epoched Data object with the epochs removed</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data">Data</a></td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#wyrm.processing.select_epochs" title="wyrm.processing.select_epochs"><code class="xref py py-func docutils literal"><span class="pre">select_epochs()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.rereference">
<code class="descclassname">wyrm.processing.</code><code class="descname">rereference</code><span class="sig-paren">(</span><em>dat</em>, <em>chan</em>, <em>chanaxis=-1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/processing.html#rereference"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.rereference" title="Permalink to this definition">¶</a></dt>
<dd><p>Rereference all channels against a single channel</p>
<p>This method rereferences all channels against a single channel by
subtracting the sample values of a reference channel. The channel
that is used as reference will consequently have all values set to
zero.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dat</strong> (<a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data"><em>Data</em></a>) &#8211; continuous or epoched Data</li>
<li><strong>chan</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; the name of the channel to use as reference. The name is case
insensitive</li>
<li><strong>chanaxis</strong> (<em>int, optional</em>) &#8211; the axis that contains the channels</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dat</strong> &#8211;
a copy of <code class="docutils literal"><span class="pre">dat</span></code> with the channels rereferenced</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Dat</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Rereference the data against <code class="docutils literal"><span class="pre">chan0</span></code></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="n">rereference</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="s">&#39;chan0&#39;</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code> (if <code class="docutils literal"><span class="pre">chan</span></code> is not in <code class="docutils literal"><span class="pre">dat</span></code>)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.segment_dat">
<code class="descclassname">wyrm.processing.</code><code class="descname">segment_dat</code><span class="sig-paren">(</span><em>dat</em>, <em>marker_def</em>, <em>ival</em>, <em>newsamples=None</em>, <em>timeaxis=-2</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/processing.html#segment_dat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.segment_dat" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a continuous data object to an epoched one.</p>
<p>Given a continuous data object, a definition of classes, and an
interval, this method looks for markers as defined in <code class="docutils literal"><span class="pre">marker_def</span></code>
and slices the dat according to the time interval given with
<code class="docutils literal"><span class="pre">ival</span></code> along the <code class="docutils literal"><span class="pre">timeaxis</span></code>. The returned <code class="docutils literal"><span class="pre">dat</span></code> object stores
those slices and the class each slice belongs to.</p>
<p>Epochs that are too close to the borders and thus too short are
ignored.</p>
<p>If the segmentation does not result in any epochs (i.e. the markers
in <code class="docutils literal"><span class="pre">marker_def</span></code> could not be found in <code class="docutils literal"><span class="pre">dat</span></code>, the resulting
dat.data will be an empty array.</p>
<p>This method is also suitable for <strong>online processing</strong>, please read
the documentation for the <code class="docutils literal"><span class="pre">newsamples</span></code> parameter and have a look
at the Examples below.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dat</strong> (<a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data"><em>Data</em></a>) &#8211; the data object to be segmented</li>
<li><strong>marker_def</strong> (<a class="reference external" href="http://docs.python.org/library/stdtypes.html#dict" title="(in Python v2.7)"><em>dict</em></a>) &#8211; The keys are class names, the values are lists of markers</li>
<li><strong>ival</strong> (<em>[int, int]</em>) &#8211; The interval in milliseconds to cut around the markers. I.e. to
get the interval starting with the marker plus the remaining
100ms define the interval like [0, 100]. The start point is
included, the endpoint is not (like: <code class="docutils literal"><span class="pre">[start,</span> <span class="pre">end)</span></code>).  To get
200ms before the marker until 100ms after the marker do:
<code class="docutils literal"><span class="pre">[-200,</span> <span class="pre">100]</span></code> Only negative or positive values are possible
(i.e. <code class="docutils literal"><span class="pre">[-500,</span> <span class="pre">-100]</span></code>)</li>
<li><strong>newsamples</strong> (<em>int, optional</em>) &#8211; <p>consider the last <code class="docutils literal"><span class="pre">newsamples</span></code> samples as new data and only
return epochs which are possible with the old <strong>and</strong> the new
data (i.e. don&#8217;t include epochs which where possible without the
new data).</p>
<p>If this parameter is <code class="docutils literal"><span class="pre">None</span></code> (default) <code class="docutils literal"><span class="pre">segment_dat</span></code> will
always process the whole <code class="docutils literal"><span class="pre">dat</span></code>, this is what you want for
offline experiments where you process the whole data from a file
at once. In online experiments however one usually gets the data
incrementally, stores it in a ringbuffer to get the last n
milliseconds. Consequently <code class="docutils literal"><span class="pre">segment_dat</span></code> gets overlapping data
in each iteration (the amount of overlap is exactly the data -
the new samples. To make sure each epoch appears only once
within all iterations, <code class="docutils literal"><span class="pre">segment_dat</span></code> needs to know the number
of new samples.</p>
</li>
<li><strong>timeaxis</strong> (<em>int, optional</em>) &#8211; the axis along which the segmentation will take place</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dat</strong> &#8211;
a copy of the resulting epoched data.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data">Data</a></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> &#8211;</p>
<ul class="last simple">
<li>if <code class="docutils literal"><span class="pre">dat</span></code> has not <code class="docutils literal"><span class="pre">.fs</span></code> or <code class="docutils literal"><span class="pre">.markers</span></code> attribute or if
<code class="docutils literal"><span class="pre">ival[0]</span> <span class="pre">&gt;</span> <span class="pre">ival[1]</span></code>.</li>
<li>if <code class="docutils literal"><span class="pre">newsamples</span></code> is not <code class="docutils literal"><span class="pre">None</span></code> or positive</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Offline Experiment</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Define the markers belonging to class 1 and 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">md</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;class 1&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s">&#39;S1&#39;</span><span class="p">,</span> <span class="s">&#39;S2&#39;</span><span class="p">],</span>
<span class="gp">... </span>      <span class="s">&#39;class 2&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s">&#39;S3&#39;</span><span class="p">,</span> <span class="s">&#39;S4&#39;</span><span class="p">]</span>
<span class="gp">... </span>     <span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Epoch the data -500ms and +700ms around the markers defined in</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># md</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">epo</span> <span class="o">=</span> <span class="n">segment_dat</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">md</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">500</span><span class="p">,</span> <span class="mi">700</span><span class="p">])</span>
</pre></div>
</div>
<p>Online Experiment</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Define the markers belonging to class 1 and 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">md</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;class 1&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s">&#39;S1&#39;</span><span class="p">,</span> <span class="s">&#39;S2&#39;</span><span class="p">],</span>
<span class="gp">... </span>      <span class="s">&#39;class 2&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s">&#39;S3&#39;</span><span class="p">,</span> <span class="s">&#39;S4&#39;</span><span class="p">]</span>
<span class="gp">... </span>     <span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># define the interval to epoch around a marker</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ival</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">300</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">dat</span><span class="p">,</span> <span class="n">mrk</span> <span class="o">=</span> <span class="n">amp</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>
<span class="gp">... </span>    <span class="n">newsamples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dat</span><span class="p">)</span>
<span class="gp">... </span>    <span class="c"># the ringbuffer shall keep the last 2000 milliseconds,</span>
<span class="gp">... </span>    <span class="c"># which is way bigger than our ival...</span>
<span class="gp">... </span>    <span class="n">ringbuffer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="n">mrk</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">cnt</span><span class="p">,</span> <span class="n">mrk</span> <span class="o">=</span> <span class="n">ringbuffer</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
<span class="gp">... </span>    <span class="c"># cnt contains now data up to 2000 millisecons, to make sure</span>
<span class="gp">... </span>    <span class="c"># we don&#39;t see old markers again and again until they where</span>
<span class="gp">... </span>    <span class="c"># pushed out of the ringbuffer, we need to tell segment_dat</span>
<span class="gp">... </span>    <span class="c"># how many samples of cnt are actually new</span>
<span class="gp">... </span>    <span class="n">epo</span> <span class="o">=</span> <span class="n">segment_dat</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">md</span><span class="p">,</span> <span class="n">ival</span><span class="p">,</span> <span class="n">newsamples</span><span class="o">=</span><span class="n">newsamples</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.select_channels">
<code class="descclassname">wyrm.processing.</code><code class="descname">select_channels</code><span class="sig-paren">(</span><em>dat</em>, <em>regexp_list</em>, <em>invert=False</em>, <em>chanaxis=-1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/processing.html#select_channels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.select_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>Select channels from data.</p>
<p>The matching is case-insensitive and locale-aware (as in
<code class="docutils literal"><span class="pre">re.IGNORECASE</span></code> and <code class="docutils literal"><span class="pre">re.LOCALE</span></code>). The regular expression always
has to match the whole channel name string</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dat</strong> (<a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data"><em>Data</em></a>) &#8211; </li>
<li><strong>regexp_list</strong> (<em>list of regular expressions</em>) &#8211; <p>The regular expressions provided, are used directly by Python&#8217;s
<a class="reference external" href="http://docs.python.org/library/re.html#module-re" title="(in Python v2.7)"><code class="xref py py-mod docutils literal"><span class="pre">re</span></code></a> module, so all regular expressions which are understood
by this module are allowed.</p>
<p>Internally the <a class="reference external" href="http://docs.python.org/library/re.html#re.match" title="(in Python v2.7)"><code class="xref py py-func docutils literal"><span class="pre">re.match()</span></code></a> method is used, additionally to
check for a match (which also matches substrings), it is also
checked if the whole string matched the pattern.</p>
</li>
<li><strong>invert</strong> (<em>Boolean, optional</em>) &#8211; If True the selection is inverted. Instead of selecting specific
channels, you are removing the channels. (default: False)</li>
<li><strong>chanaxis</strong> (<em>int, optional</em>) &#8211; the index of the channel axis in <code class="docutils literal"><span class="pre">dat</span></code> (default: -1)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dat</strong> &#8211;
A copy of <code class="docutils literal"><span class="pre">dat</span></code> with the channels, matched by the list of
regular expressions.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data">Data</a></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Select all channels Matching &#8216;af.*&#8217; or &#8216;fc.*&#8217;</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dat_new</span> <span class="o">=</span> <span class="n">select_channels</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;af.*&#39;</span><span class="p">,</span> <span class="s">&#39;fc.*&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>Remove all channels Matching &#8216;emg.*&#8217; or &#8216;eog.*&#8217;</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dat_new</span> <span class="o">=</span> <span class="n">select_channels</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;emg.*&#39;</span><span class="p">,</span> <span class="s">&#39;eog.*&#39;</span><span class="p">],</span> <span class="n">invert</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Even if you only provide one Regular expression, it has to be in an
array:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dat_new</span> <span class="o">=</span> <span class="n">select_channels</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;af.*&#39;</span><span class="p">])</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#wyrm.processing.remove_channels" title="wyrm.processing.remove_channels"><code class="xref py py-func docutils literal"><span class="pre">remove_channels()</span></code></a></dt>
<dd>Remove Channels</dd>
<dt><code class="xref py py-func docutils literal"><span class="pre">re()</span></code></dt>
<dd>Python&#8217;s Regular Expression module for more information about regular expressions.</dd>
</dl>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.select_classes">
<code class="descclassname">wyrm.processing.</code><code class="descname">select_classes</code><span class="sig-paren">(</span><em>dat</em>, <em>indices</em>, <em>invert=False</em>, <em>classaxis=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/processing.html#select_classes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.select_classes" title="Permalink to this definition">¶</a></dt>
<dd><p>Select classes from an epoched data object.</p>
<p>This method selects the classes with the specified indices.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dat</strong> (<a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data"><em>Data</em></a>) &#8211; epoched Data object</li>
<li><strong>indices</strong> (<em>array of ints</em>) &#8211; The indices of the classes to select.</li>
<li><strong>invert</strong> (<em>Boolean, optional</em>) &#8211; if true keep all classes except the ones defined by <code class="docutils literal"><span class="pre">indices</span></code>.</li>
<li><strong>classaxis</strong> (<em>int, optional</em>) &#8211; the axis along which the classes are selected</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dat</strong> &#8211;
a copy of the epoched data with only the selected classes
included.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data">Data</a></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> &#8211;
if <code class="docutils literal"><span class="pre">dat</span></code> has no <code class="docutils literal"><span class="pre">.class_names</span></code> attribute.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#wyrm.processing.remove_classes" title="wyrm.processing.remove_classes"><code class="xref py py-func docutils literal"><span class="pre">remove_classes()</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<p>Get the classes 1 and 2.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">[0, 0, 1, 2, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="n">select_classes</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">[1, 2, 2]</span>
</pre></div>
</div>
<p>Remove class 2</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">[0, 0, 1, 2, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="n">select_classes</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">invert</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">[0, 0, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.select_epochs">
<code class="descclassname">wyrm.processing.</code><code class="descname">select_epochs</code><span class="sig-paren">(</span><em>dat</em>, <em>indices</em>, <em>invert=False</em>, <em>classaxis=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/processing.html#select_epochs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.select_epochs" title="Permalink to this definition">¶</a></dt>
<dd><p>Select epochs from an epoched data object.</p>
<p>This method selects the epochs with the specified indices.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dat</strong> (<a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data"><em>Data</em></a>) &#8211; epoched Data object with an <code class="docutils literal"><span class="pre">.class_names</span></code> attribute</li>
<li><strong>indices</strong> (<em>array of ints</em>) &#8211; The indices of the elements to select.</li>
<li><strong>invert</strong> (<em>Boolean, optional</em>) &#8211; if true keep all elements except the ones defined by <code class="docutils literal"><span class="pre">indices</span></code>.</li>
<li><strong>classaxis</strong> (<em>int, optional</em>) &#8211; the axis along which the epochs are selected</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dat</strong> &#8211;
a copy of the epoched data with only the selected epochs included.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data">Data</a></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> &#8211;
if <code class="docutils literal"><span class="pre">dat</span></code> has no <code class="docutils literal"><span class="pre">.class_names</span></code> attribute.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#wyrm.processing.remove_epochs" title="wyrm.processing.remove_epochs"><code class="xref py py-func docutils literal"><span class="pre">remove_epochs()</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<p>Get the first three epochs.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">[0, 0, 1, 2, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="n">select_epochs</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">[0, 0, 1]</span>
</pre></div>
</div>
<p>Remove the fourth epoch</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">[0, 0, 1, 2, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="n">select_epochs</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">invert</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">[0, 0, 1, 2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.select_ival">
<code class="descclassname">wyrm.processing.</code><code class="descname">select_ival</code><span class="sig-paren">(</span><em>dat</em>, <em>ival</em>, <em>timeaxis=-2</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/processing.html#select_ival"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.select_ival" title="Permalink to this definition">¶</a></dt>
<dd><p>Select interval from data.</p>
<p>This method selects the time segment(s) defined by <code class="docutils literal"><span class="pre">ival</span></code>. It will
also automatically remove markers outside of the desired interval in
the returned Data object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dat</strong> (<a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data"><em>Data</em></a>) &#8211; </li>
<li><strong>ival</strong> (<em>list of two floats</em>) &#8211; Start and end in milliseconds. Start is included end is excluded
(like <code class="docutils literal"><span class="pre">[stard,</span> <span class="pre">end)</span></code>]</li>
<li><strong>timeaxis</strong> (<em>int, optional</em>) &#8211; the axis along which the intervals are selected</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dat</strong> &#8211;
a copy of <code class="docutils literal"><span class="pre">dat</span></code> with the selected time intervals.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data">Data</a></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> &#8211;
if the given interval does not fit into <code class="docutils literal"><span class="pre">dat.axes[timeaxis]</span></code>
or <code class="docutils literal"><span class="pre">ival[0]</span> <span class="pre">&gt;</span> <span class="pre">ival[1]</span></code>.</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Select the first 200ms of the epoched data:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">fs</span>
<span class="go">100.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat2</span> <span class="o">=</span> <span class="n">select_ival</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">200</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">dat2</span><span class="o">.</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dat2</span><span class="o">.</span><span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">0. 199.</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.sort_channels">
<code class="descclassname">wyrm.processing.</code><code class="descname">sort_channels</code><span class="sig-paren">(</span><em>dat</em>, <em>chanaxis=-1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/processing.html#sort_channels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.sort_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort channels.</p>
<p>This method sorts the channels in the <code class="docutils literal"><span class="pre">dat</span></code> according to the 10-20
system, from frontal to occipital and within the rows from left to
right. The method uses the <code class="docutils literal"><span class="pre">CHANNEL_10_20</span></code> list and relies on the
elements in that list to be sorted correctly. This method will put
unknown channel names to the back of the resulting list.</p>
<p>The channel matching is case agnostic.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dat</strong> (<code class="docutils literal"><span class="pre">Data</span></code> object) &#8211; </li>
<li><strong>chanaxis</strong> (<em>int, optional</em>) &#8211; the index of the channel axis in <code class="docutils literal"><span class="pre">dat</span></code></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dat</strong> &#8211;
a copy of the <code class="docutils literal"><span class="pre">dat</span></code> parameter with the channels and data
sorted.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><code class="docutils literal"><span class="pre">Data</span></code> object</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">array([&#39;PPO4&#39; &#39;CP4&#39; &#39;PCP1&#39; &#39;F5&#39; &#39;C3&#39; &#39;C4&#39; &#39;O1&#39; &#39;PPO2&#39; &#39;FFC2&#39; &#39;FAF5&#39;</span>
<span class="go">    &#39;PO1&#39; &#39;TP10&#39; &#39;FAF1&#39; &#39;FFC6&#39; &#39;FFC1&#39; &#39;PO10&#39; &#39;O10&#39; &#39;C1&#39; &#39;Cz&#39; &#39;F2&#39;</span>
<span class="go">    &#39;CFC1&#39; &#39;CCP2&#39; &#39;F4&#39; &#39;PO9&#39; &#39;CFC6&#39; &#39;TP7&#39; &#39;FC6&#39; &#39;AF8&#39; &#39;Fz&#39; &#39;AF4&#39;</span>
<span class="go">    &#39;PCP9&#39; &#39;F6&#39; &#39;FT10&#39; &#39;FAF6&#39; &#39;PO5&#39; &#39;O2&#39; &#39;OPO2&#39; &#39;AF5&#39; &#39;C2&#39; &#39;P4&#39;</span>
<span class="go">    &#39;TP9&#39; &#39;PCP7&#39; &#39;FT8&#39; &#39;A2&#39; &#39;PO6&#39; &#39;FC3&#39; &#39;PPO1&#39; &#39;CCP8&#39; &#39;OPO1&#39; &#39;AFp2&#39;</span>
<span class="go">    &#39;OI2&#39; &#39;OI1&#39; &#39;FCz&#39; &#39;CCP6&#39; &#39;CCP1&#39; &#39;CPz&#39; &#39;POz&#39; &#39;FFC3&#39; &#39;FFC7&#39; &#39;FC2&#39;</span>
<span class="go">    &#39;F1&#39; &#39;FT9&#39; &#39;P2&#39; &#39;P10&#39; &#39;T9&#39; &#39;FC1&#39; &#39;C5&#39; &#39;T7&#39; &#39;CFC4&#39; &#39;P6&#39; &#39;F8&#39;</span>
<span class="go">    &#39;TP8&#39; &#39;CFC5&#39; &#39;PCP8&#39; &#39;CFC9&#39; &#39;AF7&#39; &#39;FC5&#39; &#39;I1&#39; &#39;CFC8&#39; &#39;FFC8&#39; &#39;Oz&#39;</span>
<span class="go">    &#39;Pz&#39; &#39;PCP4&#39; &#39;FAF2&#39; &#39;PCP5&#39; &#39;CP1&#39; &#39;PCP3&#39; &#39;P1&#39; &#39;Iz&#39; &#39;CCP5&#39; &#39;PO2&#39;</span>
<span class="go">    &#39;PCP2&#39; &#39;PO4&#39; &#39;Fpz&#39; &#39;F7&#39; &#39;PO8&#39; &#39;AFz&#39; &#39;F10&#39; &#39;FFC10&#39; &#39;CCP3&#39; &#39;PPO8&#39;</span>
<span class="go">    &#39;T10&#39; &#39;AF6&#39; &#39;F9&#39; &#39;PPO5&#39; &#39;CP6&#39; &#39;I2&#39; &#39;PPO7&#39; &#39;FC4&#39; &#39;CCP4&#39; &#39;PO7&#39;</span>
<span class="go">    &#39;A1&#39; &#39;CP2&#39; &#39;CFC3&#39; &#39;T8&#39; &#39;PPO3&#39; &#39;Fp2&#39; &#39;PCP6&#39; &#39;AFp1&#39; &#39;C6&#39; &#39;FFC9&#39;</span>
<span class="go">    &#39;FT7&#39; &#39;AF3&#39; &#39;Fp1&#39; &#39;CFC10&#39; &#39;CCP7&#39; &#39;CFC7&#39; &#39;PO3&#39; &#39;P7&#39; &#39;P9&#39; &#39;FFC4&#39;</span>
<span class="go">    &#39;P5&#39; &#39;CFC2&#39; &#39;F3&#39; &#39;CP3&#39; &#39;PPO6&#39; &#39;P3&#39; &#39;O9&#39; &#39;PCP10&#39; &#39;P8&#39; &#39;CP5&#39;</span>
<span class="go">    &#39;FFC5&#39;], dtype=&#39;|S5&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="n">sort_channels</span><span class="p">(</span><span class="n">dat</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">array([&#39;Fpz&#39;, &#39;Fp1&#39;, &#39;AFp1&#39;, &#39;AFp2&#39;, &#39;Fp2&#39;, &#39;AF7&#39;, &#39;AF5&#39;, &#39;AF3&#39;,</span>
<span class="go">    &#39;AFz&#39;, &#39;AF4&#39;, &#39;AF6&#39;, &#39;AF8&#39;, &#39;FAF5&#39;, &#39;FAF1&#39;, &#39;FAF2&#39;, &#39;FAF6&#39;,</span>
<span class="go">    &#39;F9&#39;, &#39;F7&#39;, &#39;F5&#39;, &#39;F3&#39;, &#39;F1&#39;, &#39;Fz&#39;, &#39;F2&#39;, &#39;F4&#39;, &#39;F6&#39;, &#39;F8&#39;,</span>
<span class="go">    &#39;F10&#39;, &#39;FFC9&#39;, &#39;FFC7&#39;, &#39;FFC5&#39;, &#39;FFC3&#39;, &#39;FFC1&#39;, &#39;FFC2&#39;, &#39;FFC4&#39;,</span>
<span class="go">    &#39;FFC6&#39;, &#39;FFC8&#39;, &#39;FFC10&#39;, &#39;FT9&#39;, &#39;FT7&#39;, &#39;FC5&#39;, &#39;FC3&#39;, &#39;FC1&#39;,</span>
<span class="go">    &#39;FCz&#39;, &#39;FC2&#39;, &#39;FC4&#39;, &#39;FC6&#39;, &#39;FT8&#39;, &#39;FT10&#39;, &#39;CFC9&#39;, &#39;CFC7&#39;,</span>
<span class="go">    &#39;CFC5&#39;, &#39;CFC3&#39;, &#39;CFC1&#39;, &#39;CFC2&#39;, &#39;CFC4&#39;, &#39;CFC6&#39;, &#39;CFC8&#39;, &#39;CFC10&#39;,</span>
<span class="go">    &#39;T9&#39;, &#39;T7&#39;, &#39;C5&#39;, &#39;C3&#39;, &#39;C1&#39;, &#39;Cz&#39;, &#39;C2&#39;, &#39;C4&#39;, &#39;C6&#39;, &#39;T8&#39;,</span>
<span class="go">    &#39;T10&#39;, &#39;A1&#39;, &#39;CCP7&#39;, &#39;CCP5&#39;, &#39;CCP3&#39;, &#39;CCP1&#39;, &#39;CCP2&#39;, &#39;CCP4&#39;,</span>
<span class="go">    &#39;CCP6&#39;, &#39;CCP8&#39;, &#39;A2&#39;, &#39;TP9&#39;, &#39;TP7&#39;, &#39;CP5&#39;, &#39;CP3&#39;, &#39;CP1&#39;, &#39;CPz&#39;,</span>
<span class="go">    &#39;CP2&#39;, &#39;CP4&#39;, &#39;CP6&#39;, &#39;TP8&#39;, &#39;TP10&#39;, &#39;PCP9&#39;, &#39;PCP7&#39;, &#39;PCP5&#39;,</span>
<span class="go">    &#39;PCP3&#39;, &#39;PCP1&#39;, &#39;PCP2&#39;, &#39;PCP4&#39;, &#39;PCP6&#39;, &#39;PCP8&#39;, &#39;PCP10&#39;, &#39;P9&#39;,</span>
<span class="go">    &#39;P7&#39;, &#39;P5&#39;, &#39;P3&#39;, &#39;P1&#39;, &#39;Pz&#39;, &#39;P2&#39;, &#39;P4&#39;, &#39;P6&#39;, &#39;P8&#39;, &#39;P10&#39;,</span>
<span class="go">    &#39;PPO7&#39;, &#39;PPO5&#39;, &#39;PPO3&#39;, &#39;PPO1&#39;, &#39;PPO2&#39;, &#39;PPO4&#39;, &#39;PPO6&#39;, &#39;PPO8&#39;,</span>
<span class="go">    &#39;PO9&#39;, &#39;PO7&#39;, &#39;PO5&#39;, &#39;PO3&#39;, &#39;PO1&#39;, &#39;POz&#39;, &#39;PO2&#39;, &#39;PO4&#39;, &#39;PO6&#39;,</span>
<span class="go">    &#39;PO8&#39;, &#39;PO10&#39;, &#39;OPO1&#39;, &#39;OPO2&#39;, &#39;O9&#39;, &#39;O1&#39;, &#39;O2&#39;, &#39;O10&#39;, &#39;Oz&#39;,</span>
<span class="go">    &#39;OI1&#39;, &#39;OI2&#39;, &#39;I1&#39;, &#39;Iz&#39;, &#39;I2&#39;], dtype=&#39;|S5&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.spectrogram">
<code class="descclassname">wyrm.processing.</code><code class="descname">spectrogram</code><span class="sig-paren">(</span><em>cnt</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/processing.html#spectrogram"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.spectrogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the spectrogram of a continuous data object.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#wyrm.processing.spectrum" title="wyrm.processing.spectrum"><code class="xref py py-func docutils literal"><span class="pre">spectrum()</span></code></a>, <a class="reference internal" href="#wyrm.processing.stft" title="wyrm.processing.stft"><code class="xref py py-func docutils literal"><span class="pre">stft()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.spectrum">
<code class="descclassname">wyrm.processing.</code><code class="descname">spectrum</code><span class="sig-paren">(</span><em>dat</em>, <em>timeaxis=-2</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/processing.html#spectrum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the spectrum of a data object.</p>
<p>This method performs a fast fourier transform on the data along the
timeaxis and returns a new <cite>Data</cite> object which is transformed into
the frequency domain. The values are the amplitudes of of the
respective frequencies.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dat</strong> (<a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data"><em>Data</em></a>) &#8211; Data object with <cite>.fs</cite> attribute</li>
<li><strong>timeaxis</strong> (<em>int, optional</em>) &#8211; axis to perform the fft along</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dat</strong> &#8211;
Data object with the timeaxis transformed into the frequency
domain. The values of the spectrum are the amplitudes of the
respective frequencies.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data">Data</a></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># dat can be continuous or epoched</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">axes</span>
<span class="go">[&#39;time&#39;, &#39;channel&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spm</span> <span class="o">=</span> <span class="n">spectrum</span><span class="p">(</span><span class="n">dat</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spm</span><span class="o">.</span><span class="n">axes</span>
<span class="go">[&#39;frequency&#39;, &#39;channel&#39;]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> &#8211;
if the <code class="docutils literal"><span class="pre">dat</span></code> parameter has no <code class="docutils literal"><span class="pre">.fs</span></code> attribute</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#wyrm.processing.spectrogram" title="wyrm.processing.spectrogram"><code class="xref py py-func docutils literal"><span class="pre">spectrogram()</span></code></a>, <a class="reference internal" href="#wyrm.processing.stft" title="wyrm.processing.stft"><code class="xref py py-func docutils literal"><span class="pre">stft()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.square">
<code class="descclassname">wyrm.processing.</code><code class="descname">square</code><span class="sig-paren">(</span><em>dat</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/processing.html#square"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.square" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the element wise square of <code class="docutils literal"><span class="pre">dat.data</span></code>.</p>
<p>Calling this method is equivalent to calling</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dat</strong> (<a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data"><em>Data</em></a>) &#8211; a Data object</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>dat</strong> &#8211;
a copy of <code class="docutils literal"><span class="pre">dat</span></code> with the element wise squares of the values in
<code class="docutils literal"><span class="pre">.data</span></code></td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data">Data</a></td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#wyrm.processing.logarithm" title="wyrm.processing.logarithm"><code class="xref py py-func docutils literal"><span class="pre">logarithm()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.stft">
<code class="descclassname">wyrm.processing.</code><code class="descname">stft</code><span class="sig-paren">(</span><em>x</em>, <em>width</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/processing.html#stft"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.stft" title="Permalink to this definition">¶</a></dt>
<dd><p>Short time fourier transform of a real sequence.</p>
<p>This method performs a discrete short time Fourier transform. It
uses a sliding window to perform discrete Fourier transforms on the
data in the Window. The results are returned in an array.</p>
<p>This method uses a Hanning window on the data in the window before
calculating the Fourier transform.</p>
<p>The sliding windows are overlapping by <code class="docutils literal"><span class="pre">width</span> <span class="pre">/</span> <span class="pre">2</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>ndarray</em>) &#8211; </li>
<li><strong>width</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; the width of the sliding window in samples</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fourier</strong> &#8211;
the dimensions are time, frequency; the frequencies are evenly
binned from 0 to f_nyquist</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">2d complex array</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#wyrm.processing.spectrum" title="wyrm.processing.spectrum"><code class="xref py py-func docutils literal"><span class="pre">spectrum()</span></code></a>, <a class="reference internal" href="#wyrm.processing.spectrogram" title="wyrm.processing.spectrogram"><code class="xref py py-func docutils literal"><span class="pre">spectrogram()</span></code></a>, <code class="xref py py-func docutils literal"><span class="pre">scipy.hanning()</span></code>, <code class="xref py py-func docutils literal"><span class="pre">scipy.fftpack.rfft()</span></code></p>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.subsample">
<code class="descclassname">wyrm.processing.</code><code class="descname">subsample</code><span class="sig-paren">(</span><em>dat</em>, <em>freq</em>, <em>timeaxis=-2</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/processing.html#subsample"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.subsample" title="Permalink to this definition">¶</a></dt>
<dd><p>Subsample the data to <code class="docutils literal"><span class="pre">freq</span></code> Hz.</p>
<p>This method subsamples data along <code class="docutils literal"><span class="pre">timeaxis</span></code> by taking every <code class="docutils literal"><span class="pre">n</span></code>
th element starting with the first one and <code class="docutils literal"><span class="pre">n</span></code> being <code class="docutils literal"><span class="pre">dat.fs</span> <span class="pre">/</span>
<span class="pre">freq</span></code>. Please note that <code class="docutils literal"><span class="pre">freq</span></code> must be a whole number divisor of
<code class="docutils literal"><span class="pre">dat.fs</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Note that this method does not low-pass filter the data before
sub-sampling.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>If you use this method in an on-line setting (i.e. where you
process the data in chunks and not as a whole), you should make
sure that <code class="docutils literal"><span class="pre">subsample</span></code> does not drop &#8220;half samples&#8221; by ensuring
the source data&#8217;s length is in multiples of the target data&#8217;s
sample length.</p>
<p class="last">Let&#8217;s assume your source data is sampled in 1kHz and you want to
subsample down to 100Hz. One sample of the source data is 1ms
long, while the target samples will be 10ms long. In order to
ensure that <code class="docutils literal"><span class="pre">subsample</span></code> does not eat fractions of samples at
the end of your data, you have to make sure that your source
data is multiples of 10ms (i.e. 1010, 1020, etc) long. You might
want to use <a class="reference internal" href="#wyrm.types.BlockBuffer" title="wyrm.types.BlockBuffer"><code class="xref py py-class docutils literal"><span class="pre">wyrm.types.BlockBuffer</span></code></a> for this (see
Examples below).</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dat</strong> (<a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data"><em>Data</em></a>) &#8211; Data object with <code class="docutils literal"><span class="pre">.fs</span></code> attribute</li>
<li><strong>freq</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; the target frequency in Hz</li>
<li><strong>timeaxis</strong> (<em>int, optional</em>) &#8211; the axis along which to subsample</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dat</strong> &#8211;
copy of <code class="docutils literal"><span class="pre">dat</span></code> with subsampled frequency</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data">Data</a></p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#wyrm.processing.lfilter" title="wyrm.processing.lfilter"><code class="xref py py-func docutils literal"><span class="pre">lfilter()</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<p>Load some EEG data with 1kHz, bandpass filter it and downsample it
to 100Hz.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="n">load_brain_vision_data</span><span class="p">(</span><span class="s">&#39;some/path&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">fs</span>
<span class="go">1000.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fn</span> <span class="o">=</span> <span class="n">dat</span><span class="o">.</span><span class="n">fs</span> <span class="o">/</span> <span class="mi">2</span> <span class="c"># nyquist frequ</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">butter</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="p">[</span><span class="mi">8</span> <span class="o">/</span> <span class="n">fn</span><span class="p">,</span> <span class="mi">40</span> <span class="o">/</span> <span class="n">fn</span><span class="p">],</span> <span class="n">btype</span><span class="o">=</span><span class="s">&#39;band&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="n">lfilter</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="n">subsample</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">fs</span>
<span class="go">100.0</span>
</pre></div>
</div>
<p>Online Experiment</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">bbuffer</span> <span class="o">=</span> <span class="n">BlockBuffer</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="c"># 10 ms is the target block size</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">cnt</span> <span class="o">=</span> <span class="o">...</span> <span class="c"># get 1kHz continous data from your amp</span>
<span class="gp">... </span>    <span class="c"># put the data into the block buffer</span>
<span class="gp">... </span>    <span class="c"># bbget will onlry return the data in multiples of 10ms or</span>
<span class="gp">... </span>    <span class="c"># nothing</span>
<span class="gp">... </span>    <span class="n">bbuffer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cnt</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">cnt</span> <span class="o">=</span> <span class="n">bbuffer</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="ow">not</span> <span class="n">cnt</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">continue</span>
<span class="gp">... </span>    <span class="c"># filter, etc</span>
<span class="gp">... </span>    <span class="n">subsample</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> &#8211;
* if <code class="docutils literal"><span class="pre">freq</span></code> is not a whole number divisor of <code class="docutils literal"><span class="pre">dat.fs</span></code>
* if <code class="docutils literal"><span class="pre">dat</span></code> has no <code class="docutils literal"><span class="pre">.fs</span></code> attribute
* if <code class="docutils literal"><span class="pre">dat.data.shape[timeaxis]</span> <span class="pre">!=</span> <span class="pre">len(dat.axes[timeaxis])</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.swapaxes">
<code class="descclassname">wyrm.processing.</code><code class="descname">swapaxes</code><span class="sig-paren">(</span><em>dat</em>, <em>ax1</em>, <em>ax2</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/processing.html#swapaxes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.swapaxes" title="Permalink to this definition">¶</a></dt>
<dd><p>Swap axes of a Data object.</p>
<p>This method swaps two axes of a Data object by swapping the
appropriate <code class="docutils literal"><span class="pre">.data</span></code>, <code class="docutils literal"><span class="pre">.names</span></code>, <code class="docutils literal"><span class="pre">.units</span></code>, and <code class="docutils literal"><span class="pre">.axes</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dat</strong> (<a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data"><em>Data</em></a>) &#8211; </li>
<li><strong>ax2</strong> (<em>ax1,</em>) &#8211; the indices of the axes to swap</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dat</strong> &#8211;
a copy of <code class="docutils literal"><span class="pre">dat</span></code> with the appropriate axes swapped.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data">Data</a></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">names</span>
<span class="go">[&#39;time&#39;, &#39;channels&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="n">swapaxes</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">names</span>
<span class="go">[&#39;channels&#39;, &#39;time&#39;]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-func docutils literal"><span class="pre">numpy.swapaxes()</span></code></p>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.variance">
<code class="descclassname">wyrm.processing.</code><code class="descname">variance</code><span class="sig-paren">(</span><em>dat</em>, <em>timeaxis=-2</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/processing.html#variance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.variance" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the variance along the <code class="docutils literal"><span class="pre">timeaxis</span></code> of <code class="docutils literal"><span class="pre">dat</span></code>.</p>
<p>This method reduces the dimensions of <cite>dat.data</cite> by one.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dat</strong> (<a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data"><em>Data</em></a>) &#8211; </td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>dat</strong> &#8211;
copy of <code class="docutils literal"><span class="pre">dat</span></code> with with the variance along the <code class="docutils literal"><span class="pre">timeaxis</span></code>
removed and <code class="docutils literal"><span class="pre">timeaxis</span></code> removed.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data">Data</a></td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">epo</span><span class="o">.</span><span class="n">names</span>
<span class="go">[&#39;class&#39;, &#39;time&#39;, &#39;channel&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">var</span> <span class="o">=</span> <span class="n">variance</span><span class="p">(</span><span class="n">cnt</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">var</span><span class="o">.</span><span class="n">names</span>
<span class="go">[&#39;class&#39;, &#39;channel&#39;]</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-wyrm.types">
<span id="wyrm-types-module"></span><h2>wyrm.types module<a class="headerlink" href="#module-wyrm.types" title="Permalink to this headline">¶</a></h2>
<p>Data type definitions.</p>
<p>This module provides the basic data types for Wyrm, like the
<a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data"><code class="xref py py-class docutils literal"><span class="pre">Data</span></code></a> and <a class="reference internal" href="#wyrm.types.RingBuffer" title="wyrm.types.RingBuffer"><code class="xref py py-class docutils literal"><span class="pre">RingBuffer</span></code></a> classes.</p>
<dl class="class">
<dt id="wyrm.types.BlockBuffer">
<em class="property">class </em><code class="descclassname">wyrm.types.</code><code class="descname">BlockBuffer</code><span class="sig-paren">(</span><em>samples=50</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/types.html#BlockBuffer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.types.BlockBuffer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="http://docs.python.org/library/functions.html#object" title="(in Python v2.7)"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a></p>
<p>A buffer that returns data chunks in multiples of a block length.</p>
<p>This buffer is a first-in-first-out (FIFO) buffer that returns data
in multiples of a desired block length. The block length is defined
in samples.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>samples</strong> (<em>int, optional</em>) &#8211; the desired block length in samples</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">bbuffer</span> <span class="o">=</span> <span class="n">BlockBuffer</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
<span class="gp">... </span><span class="n">cnt</span> <span class="o">=</span> <span class="n">some_aquisition_method</span><span class="p">()</span>
<span class="gp">... </span><span class="c"># How to use the BlockBuffer</span>
<span class="gp">... </span><span class="n">bbuffer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cnt</span><span class="p">)</span>
<span class="gp">... </span><span class="n">cnt</span> <span class="o">=</span> <span class="n">bbuffer</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
<span class="gp">... </span><span class="k">if</span> <span class="ow">not</span> <span class="n">cnt</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">continue</span>
<span class="gp">... </span><span class="c"># after here cnt is guaranteed to be in multiples of 10 samples</span>
</pre></div>
</div>
<dl class="method">
<dt id="wyrm.types.BlockBuffer.append">
<code class="descname">append</code><span class="sig-paren">(</span><em>dat</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/types.html#BlockBuffer.append"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.types.BlockBuffer.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Append data to the Block Buffer.</p>
<p>This method accumulates the incoming data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dat</strong> (<a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data"><em>Data</em></a>) &#8211; continuous Data object</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="wyrm.types.BlockBuffer.get">
<code class="descname">get</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/types.html#BlockBuffer.get"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.types.BlockBuffer.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Pop the contents of the Block Buffer.</p>
<p>The data returned has a length of multiples of <code class="docutils literal"><span class="pre">samples</span></code>. If
there is a fraction of <code class="docutils literal"><span class="pre">samples</span></code> data more in the buffer, that
data is kept and future <a class="reference internal" href="#wyrm.types.BlockBuffer.append" title="wyrm.types.BlockBuffer.append"><code class="xref py py-meth docutils literal"><span class="pre">append()</span></code></a> operations will append
new data to it.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>dat</strong> &#8211;
continuous Data object</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data">Data</a></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="wyrm.types.Data">
<em class="property">class </em><code class="descclassname">wyrm.types.</code><code class="descname">Data</code><span class="sig-paren">(</span><em>data</em>, <em>axes</em>, <em>names</em>, <em>units</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/types.html#Data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.types.Data" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="http://docs.python.org/library/functions.html#object" title="(in Python v2.7)"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a></p>
<p>Generic, self-describing data container.</p>
<p>This data structure is very generic on purpose. The goal here was to
provide something which can fit the various different known and yet
unknown requirements for BCI algorithms.</p>
<p>At the core of <code class="docutils literal"><span class="pre">Data</span></code> is its n-dimensional <code class="docutils literal"><span class="pre">.data</span></code> attribute
which holds the actual data. Along with the data, there is meta
information about each axis of the data, contained in <code class="docutils literal"><span class="pre">.axes</span></code>,
<code class="docutils literal"><span class="pre">.names</span></code>, and <code class="docutils literal"><span class="pre">.units</span></code>.</p>
<p>Most toolbox methods rely on a <em>convention</em> how specific data should
be structured (i.e. they assume that the channels are always in the
last dimension). You don&#8217;t have to follow this convention (or
sometimes it might not even be possible when trying out new things),
and all methods, provide an optional parameter to tell them on which
axis they should work on.</p>
<dl class="docutils">
<dt>Continuous Data:</dt>
<dd>Continuous Data is usually EEG data and consists of a 2d array
<code class="docutils literal"><span class="pre">[time,</span> <span class="pre">channel]</span></code>. Whenever you have continuous data, time and
channel should be the last two dimensions.</dd>
<dt>Epoched Data:</dt>
<dd>Epoched data can be seen as an array of (non-epoched) data. The
epoch should always be the first dimension. Most commonly used is
epoched continuous EEG data which looks like this: <code class="docutils literal"><span class="pre">[class,</span>
<span class="pre">time,</span> <span class="pre">channel]</span></code>.</dd>
<dt>Feature Vector:</dt>
<dd>Similar to Epoched Data, with classes in the first dimension.</dd>
</dl>
<p><a class="reference internal" href="#wyrm.types.Data.__eq__" title="wyrm.types.Data.__eq__"><code class="xref py py-meth docutils literal"><span class="pre">Data.__eq__()</span></code></a> and <a class="reference internal" href="#wyrm.types.Data.__ne__" title="wyrm.types.Data.__ne__"><code class="xref py py-meth docutils literal"><span class="pre">Data.__ne__()</span></code></a> functions are provided
to test for equality of two Data objects (via <code class="docutils literal"><span class="pre">==</span></code> and <code class="docutils literal"><span class="pre">!=</span></code>).
This method only checks for the known attributes and does not
guaranty correct result if the Data object contains custom
attributes. It is mainly used in unittests.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>data</strong> (<em>ndarray</em>) &#8211; </li>
<li><strong>axes</strong> (<em>nlist of 1darrays</em>) &#8211; </li>
<li><strong>names</strong> (<em>nlist of strings</em>) &#8211; </li>
<li><strong>units</strong> (<em>nlist of strings</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="wyrm.types.Data.data">
<code class="descname">data</code><a class="headerlink" href="#wyrm.types.Data.data" title="Permalink to this definition">¶</a></dt>
<dd><p><em>ndarray</em></p>
<p>n-dimensional data array if the array is empty
(i.e. <code class="docutils literal"><span class="pre">data.size</span> <span class="pre">==</span> <span class="pre">0</span></code>), the <code class="docutils literal"><span class="pre">Data</span></code> object is assumed to be
empty</p>
</dd></dl>

<dl class="attribute">
<dt id="wyrm.types.Data.axes">
<code class="descname">axes</code><a class="headerlink" href="#wyrm.types.Data.axes" title="Permalink to this definition">¶</a></dt>
<dd><p><em>nlist of 1-darrays</em></p>
<p>each element of corresponds to a dimension of <code class="docutils literal"><span class="pre">.data</span></code> (i.e.
the first one in <code class="docutils literal"><span class="pre">.axes</span></code> to the first dimension in <code class="docutils literal"><span class="pre">.data</span></code>
and so on). The 1-dimensional arrays contain the description of
the data along the appropriate axis in <code class="docutils literal"><span class="pre">.data</span></code>. For example if
<code class="docutils literal"><span class="pre">.data</span></code> contains Continuous Data, then <code class="docutils literal"><span class="pre">.axes[0]</span></code> should be
an array of timesteps and <code class="docutils literal"><span class="pre">.axes[1]</span></code> an array of channel names</p>
</dd></dl>

<dl class="attribute">
<dt id="wyrm.types.Data.names">
<code class="descname">names</code><a class="headerlink" href="#wyrm.types.Data.names" title="Permalink to this definition">¶</a></dt>
<dd><p><em>nlist of strings</em></p>
<p>the human readable description of each axis, like &#8216;time&#8217;, or
&#8216;channel&#8217;</p>
</dd></dl>

<dl class="attribute">
<dt id="wyrm.types.Data.units">
<code class="descname">units</code><a class="headerlink" href="#wyrm.types.Data.units" title="Permalink to this definition">¶</a></dt>
<dd><p><em>nlist of strings</em></p>
<p>the human readable description of the unit used for the data in
<code class="docutils literal"><span class="pre">.axes</span></code></p>
</dd></dl>

<dl class="method">
<dt id="wyrm.types.Data.__bool__">
<code class="descname">__bool__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/types.html#Data.__bool__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.types.Data.__bool__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return truth value of the object instance.</p>
<p>This method returns False if the __nonzero__ value is 0 else
True.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>truth</strong> &#8211;
<code class="docutils literal"><span class="pre">False</span></code> if <a class="reference internal" href="#wyrm.types.Data.__nonzero__" title="wyrm.types.Data.__nonzero__"><code class="xref py py-func docutils literal"><span class="pre">__nonzero__()</span></code></a> was <code class="docutils literal"><span class="pre">0</span></code>, else <code class="docutils literal"><span class="pre">True</span></code>.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">Bool</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#wyrm.types.Data.__nonzero__" title="wyrm.types.Data.__nonzero__"><code class="xref py py-func docutils literal"><span class="pre">__nonzero__()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="wyrm.types.Data.__eq__">
<code class="descname">__eq__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/types.html#Data.__eq__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.types.Data.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Test for equality.</p>
<p>Don&#8217;t trust this method it only checks for known attributes and
assumes equality if those are equal. This method is heavily used
in unittests.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> (<a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data"><em>Data</em></a>) &#8211; </td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>equal</strong> &#8211;
True if <code class="docutils literal"><span class="pre">self</span></code> and <code class="docutils literal"><span class="pre">other</span></code> are equal, False if not.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">Boolean</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="wyrm.types.Data.__ne__">
<code class="descname">__ne__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/types.html#Data.__ne__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.types.Data.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Test for inequality.</p>
<p>If <a class="reference internal" href="#wyrm.types.Data.__eq__" title="wyrm.types.Data.__eq__"><code class="xref py py-func docutils literal"><span class="pre">__eq__()</span></code></a> is implemented and <a class="reference internal" href="#wyrm.types.Data.__ne__" title="wyrm.types.Data.__ne__"><code class="xref py py-func docutils literal"><span class="pre">__ne__()</span></code></a> is not,
strange comparisons evaluate to True like:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">d1</span> <span class="o">==</span> <span class="n">d2</span> <span class="ow">and</span> <span class="n">d1</span> <span class="o">!=</span> <span class="n">d2</span>
</pre></div>
</div>
<p>This method just returns the negation of <a class="reference internal" href="#wyrm.types.Data.__eq__" title="wyrm.types.Data.__eq__"><code class="xref py py-meth docutils literal"><span class="pre">__eq__()</span></code></a>. So the
same restrictions of <a class="reference internal" href="#wyrm.types.Data.__eq__" title="wyrm.types.Data.__eq__"><code class="xref py py-meth docutils literal"><span class="pre">__eq__()</span></code></a> about its reliability apply.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> (<a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data"><em>Data</em></a>) &#8211; </td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>equal</strong> &#8211;
True if <code class="docutils literal"><span class="pre">self</span></code> and <code class="docutils literal"><span class="pre">other</span></code> are not equal, False
otherwise.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">Boolean</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="wyrm.types.Data.__nonzero__">
<code class="descname">__nonzero__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/types.html#Data.__nonzero__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.types.Data.__nonzero__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the truth value for the object instance.</p>
<p>Similar to Python&#8217;s built in types we return <code class="docutils literal"><span class="pre">False</span></code> if the
data instance is empty and <code class="docutils literal"><span class="pre">True</span></code> otherwise. Please note that
we only check for the size of <code class="docutils literal"><span class="pre">.data</span></code> and ignore other
attributes like <code class="docutils literal"><span class="pre">.markers</span></code> which might not be empty.</p>
<p class="rubric">Examples</p>
<p>Easy checking if a data object contains data or not:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="ow">not</span> <span class="n">cnt</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">continue</span>
</pre></div>
</div>
<p>is equivalent to:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="n">cnt</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">continue</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>nonzero</strong> &#8211;
<code class="docutils literal"><span class="pre">self.data.size</span></code></td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)">int</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="wyrm.types.Data.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/types.html#Data.__str__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.types.Data.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Human readable representation for a data object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>str</strong> &#8211;
a human readable representation of the data object</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)">str</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="wyrm.types.Data.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/types.html#Data.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.types.Data.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a memory efficient deep copy of <code class="docutils literal"><span class="pre">self</span></code>.</p>
<p>It first creates a shallow copy of <code class="docutils literal"><span class="pre">self</span></code>, sets the attributes
in <code class="docutils literal"><span class="pre">kwargs</span></code> if necessary and returns a deep copy of the
resulting object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>kwargs</strong> (<em>dict, optional</em>) &#8211; if provided <code class="docutils literal"><span class="pre">copy</span></code> will try to overwrite the name, value
pairs after the shallow- and before the deep copy. If no
<code class="docutils literal"><span class="pre">kwargs</span></code> are provided, it will just return the deep copy.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>dat</strong> &#8211;
a deep copy of <code class="docutils literal"><span class="pre">self</span></code>.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data">Data</a></td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># perform an ordinary deep copy of dat</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat2</span> <span class="o">=</span> <span class="n">dat</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># perform a deep copy but overwrite .axes first</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">axes</span>
<span class="go">[&#39;time&#39;, &#39;channels&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat3</span> <span class="o">=</span> <span class="n">dat</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;foo&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s">&#39;bar&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat3</span><span class="o">.</span><span class="n">axes</span>
<span class="go">[&#39;foo&#39;, &#39;bar&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">axes</span>
<span class="go">[&#39;time&#39;, &#39;channel&#39;]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="wyrm.types.RingBuffer">
<em class="property">class </em><code class="descclassname">wyrm.types.</code><code class="descname">RingBuffer</code><span class="sig-paren">(</span><em>length_ms</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/types.html#RingBuffer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.types.RingBuffer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="http://docs.python.org/library/functions.html#object" title="(in Python v2.7)"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a></p>
<p>Circular Buffer implementation.</p>
<p>This implementation has a guaranteed upper bound for read and write
operations as well as a constant memory usage, which is the size of
the maximum length of the buffer in memory.</p>
<p>Reading and writing will take at most the time it takes to copy a
continuous chunk of length <code class="docutils literal"><span class="pre">MAXLEN</span></code> in memory. E.g. for the
extreme case of storing the last 60 seconds of 64bit data, sampled
with 1kHz and 128 channels (~60MB), reading a full buffer will take
~25ms, as well as writing when storing more than than 60 seconds at
once. Writing will be usually much faster, as one stores usually
only a few milliseconds of data per run. In that case writing will
be a fraction of a millisecond.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>length_ms</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; the length of the ring buffer in milliseconds</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="wyrm.types.RingBuffer.length_ms">
<code class="descname">length_ms</code><a class="headerlink" href="#wyrm.types.RingBuffer.length_ms" title="Permalink to this definition">¶</a></dt>
<dd><p><em>int</em></p>
<p>the length of the ring buffer in milliseconds</p>
</dd></dl>

<dl class="attribute">
<dt id="wyrm.types.RingBuffer.length">
<code class="descname">length</code><a class="headerlink" href="#wyrm.types.RingBuffer.length" title="Permalink to this definition">¶</a></dt>
<dd><p><em>int</em></p>
<p>the length of the ring buffer in samples</p>
</dd></dl>

<dl class="attribute">
<dt id="wyrm.types.RingBuffer.data">
<code class="descname">data</code><a class="headerlink" href="#wyrm.types.RingBuffer.data" title="Permalink to this definition">¶</a></dt>
<dd><p><em>ndarray</em></p>
<p>the contents of the ring buffer, you should not read or write
this attribute directly but via the <a class="reference internal" href="#wyrm.types.RingBuffer.get" title="wyrm.types.RingBuffer.get"><code class="xref py py-meth docutils literal"><span class="pre">RingBuffer.get()</span></code></a> and
<a class="reference internal" href="#wyrm.types.RingBuffer.append" title="wyrm.types.RingBuffer.append"><code class="xref py py-meth docutils literal"><span class="pre">RingBuffer.append()</span></code></a> methods</p>
</dd></dl>

<dl class="attribute">
<dt id="wyrm.types.RingBuffer.markers">
<code class="descname">markers</code><a class="headerlink" href="#wyrm.types.RingBuffer.markers" title="Permalink to this definition">¶</a></dt>
<dd><p><em>array of [int, str]</em></p>
<p>the markers belonging to the data currently in the ring buffer</p>
</dd></dl>

<dl class="attribute">
<dt id="wyrm.types.RingBuffer.full">
<code class="descname">full</code><a class="headerlink" href="#wyrm.types.RingBuffer.full" title="Permalink to this definition">¶</a></dt>
<dd><p><em>boolean</em></p>
<p>indicates if the buffer has at least <code class="docutils literal"><span class="pre">length</span></code> elements stored</p>
</dd></dl>

<dl class="attribute">
<dt id="wyrm.types.RingBuffer.idx">
<code class="descname">idx</code><a class="headerlink" href="#wyrm.types.RingBuffer.idx" title="Permalink to this definition">¶</a></dt>
<dd><p><em>int</em></p>
<p>the starting position of the oldest data in the ring buffer</p>
</dd></dl>

<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">RingBuffer</span><span class="p">(</span><span class="n">length</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">rb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">amp</span><span class="o">.</span><span class="n">get_data</span><span class="p">())</span>
<span class="gp">... </span>    <span class="n">buffered</span> <span class="o">=</span> <span class="n">rb</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
<span class="gp">... </span>    <span class="c"># do something with buffered</span>
</pre></div>
</div>
<dl class="method">
<dt id="wyrm.types.RingBuffer.append">
<code class="descname">append</code><span class="sig-paren">(</span><em>dat</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/types.html#RingBuffer.append"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.types.RingBuffer.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Append data to the Ringbuffer, overwriting old data if necessary.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dat</strong> (<a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data"><em>Data</em></a>) &#8211; a continuous data object</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code> &#8211;
if the [1:]-dimensions (all but the first one) of <code class="docutils literal"><span class="pre">data</span></code>
does not match the ring buffer dimensions</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="wyrm.types.RingBuffer.get">
<code class="descname">get</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/wyrm/types.html#RingBuffer.get"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.types.RingBuffer.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all buffered data.</p>
<p>The returned data will have <em>at most</em> the length of <code class="docutils literal"><span class="pre">length</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>data</strong> &#8211;
the full contents of the ring buffer</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data">Data</a></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-wyrm">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-wyrm" title="Permalink to this headline">¶</a></h2>
<p>This is Wyrm.</p>
<p>Some words describing the Wyrm package.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">wyrm package</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-wyrm.io">wyrm.io module</a></li>
<li><a class="reference internal" href="#module-wyrm.plot">wyrm.plot module</a></li>
<li><a class="reference internal" href="#module-wyrm.processing">wyrm.processing module</a></li>
<li><a class="reference internal" href="#module-wyrm.types">wyrm.types module</a></li>
<li><a class="reference internal" href="#module-wyrm">Module contents</a></li>
</ul>
</li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Wyrm 1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2012 - 2015, Bastian Venthur.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>