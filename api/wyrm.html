<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>wyrm package &mdash; Wyrm 0.7.beta documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.7.beta',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="top" title="Wyrm 0.7.beta documentation" href="../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">Wyrm 0.7.beta documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="wyrm-package">
<h1>wyrm package<a class="headerlink" href="#wyrm-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-wyrm.io">
<span id="wyrm-io-module"></span><h2>wyrm.io module<a class="headerlink" href="#module-wyrm.io" title="Permalink to this headline">¶</a></h2>
<p>Input/Output methods.</p>
<p>This module provides methods for loading and saving data into various
formats.</p>
<dl class="function">
<dt id="wyrm.io.load_brain_vision_data">
<tt class="descclassname">wyrm.io.</tt><tt class="descname">load_brain_vision_data</tt><big>(</big><em>vhdr</em><big>)</big><a class="reference internal" href="../_modules/wyrm/io.html#load_brain_vision_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.io.load_brain_vision_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Load Brain Vision data from a file.</p>
<p>This methods loads the continuous EEG data, and returns a <tt class="docutils literal"><span class="pre">Data</span></tt>
object of continuous data <tt class="docutils literal"><span class="pre">[time,</span> <span class="pre">channel]</span></tt>, along with the
markers and the sampling frequency. The EEG data is returned in
micro Volt.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>vhdr</strong> : str</p>
<blockquote>
<div><p>Path to a VHDR file</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dat</strong> : Data</p>
<blockquote>
<div><p>Continuous Data with the additional attributes <tt class="docutils literal"><span class="pre">.fs</span></tt> for the
sampling frequency and <tt class="docutils literal"><span class="pre">.marker</span></tt> for a list of markers. Each
marker is a tuple of <tt class="docutils literal"><span class="pre">(time</span> <span class="pre">in</span> <span class="pre">ms,</span> <span class="pre">marker)</span></tt>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>AssertionError</strong> :</p>
<blockquote class="last">
<div><p>If one of the consistency checks fails</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="n">load_brain_vision_data</span><span class="p">(</span><span class="s">&#39;path/to/vhdr&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">fs</span>
<span class="go">1000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(54628, 61)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.io.load_mushu_data">
<tt class="descclassname">wyrm.io.</tt><tt class="descname">load_mushu_data</tt><big>(</big><em>meta</em><big>)</big><a class="reference internal" href="../_modules/wyrm/io.html#load_mushu_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.io.load_mushu_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Load saved EEG data in Mushu&#8217;s format.</p>
<p>This method loads saved data in Mushu&#8217;s format and returns a
continuous <tt class="docutils literal"><span class="pre">Data</span></tt> object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>meta</strong> : str</p>
<blockquote>
<div><p>Path to <cite>.meta</cite> file. A Mushu recording consists of three
different files: <cite>.eeg</cite>, <cite>.marker</cite>, and <cite>.meta</cite>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dat</strong> : Data</p>
<blockquote class="last">
<div><p>Continuous Data object</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="n">load_mushu_data</span><span class="p">(</span><span class="s">&#39;testrecording.meta&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-wyrm.plot">
<span id="wyrm-plot-module"></span><h2>wyrm.plot module<a class="headerlink" href="#module-wyrm.plot" title="Permalink to this headline">¶</a></h2>
<p>Plotting methods.</p>
<p>This module contains various plotting methods. There are two types of
plotting methods: the Primitives and the Composites. The Primitives are
the most basic and offer simple, single-plot representations. The
Composites are composed of several primitives and offer more complex
representations.</p>
<p>The primitive plots are those whose name begin with <tt class="docutils literal"><span class="pre">ax_</span></tt>, (e.g.
<tt class="docutils literal"><span class="pre">ax_scalp</span></tt>).</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>This module needs heavy reworking! We have yet to find a consistent
way to handle primitive and composite plots, deal with the fact that
some plots just manipulate axes, while others operate on figures and
have to decide on which layer of matplotlib we want to deal with
(i.e. pyplot, artist or even pylab).</p>
<p class="last">The API of this module will change and you should not rely on any
method here.</p>
</div>
<dl class="function">
<dt id="wyrm.plot.ax_colorbar">
<tt class="descclassname">wyrm.plot.</tt><tt class="descname">ax_colorbar</tt><big>(</big><em>vmin</em>, <em>vmax</em>, <em>ax=None</em>, <em>label=None</em>, <em>ticks=None</em><big>)</big><a class="reference internal" href="../_modules/wyrm/plot.html#ax_colorbar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.plot.ax_colorbar" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw a color bar</p>
<p>Draws a color bar on an existing axes. The range of the colors is
defined by <tt class="docutils literal"><span class="pre">vmin</span></tt> and <tt class="docutils literal"><span class="pre">vmax</span></tt>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Unlike the colorbar method from matplotlib, this method does not
automatically create a new axis for the colorbar. It will paint
in the currently active axis instead, overwriting any existing
plots in that axis. Make sure to create a new axis for the
colorbar.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>vmin, vmax</strong> : float</p>
<blockquote>
<div><p>The minimum and maximum values for the colorbar.</p>
</div></blockquote>
<p><strong>ax</strong> : Axes, optional</p>
<blockquote>
<div><p>The axes to draw the scalp plot on. If not provided, the
currently activated axes (i.e. <tt class="docutils literal"><span class="pre">gca()</span></tt>) will be taken</p>
</div></blockquote>
<p><strong>label</strong> : string, optional</p>
<blockquote>
<div><p>The label for the colorbar</p>
</div></blockquote>
<p><strong>ticks</strong> : list, optional</p>
<blockquote>
<div><p>The tick positions</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ax</strong> : Axes</p>
<blockquote class="last">
<div><p>the axes on which the plot was drawn</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="wyrm.plot.ax_scalp">
<tt class="descclassname">wyrm.plot.</tt><tt class="descname">ax_scalp</tt><big>(</big><em>v</em>, <em>channels</em>, <em>ax=None</em>, <em>annotate=False</em>, <em>vmin=None</em>, <em>vmax=None</em><big>)</big><a class="reference internal" href="../_modules/wyrm/plot.html#ax_scalp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.plot.ax_scalp" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw a scalp plot.</p>
<p>Draws a scalp plot on an existing axes. The method takes an array of
values and an array of the corresponding channel names. It matches
the channel names with an internal list of known channels and their
positions to project them correctly on the scalp.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The behaviour for unkown channels is undefined.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>v</strong> : 1d-array of floats</p>
<blockquote>
<div><p>The values for the channels</p>
</div></blockquote>
<p><strong>channels</strong> : 1d array of strings</p>
<blockquote>
<div><p>The corresponding channel names for the values in <tt class="docutils literal"><span class="pre">v</span></tt></p>
</div></blockquote>
<p><strong>ax</strong> : Axes, optional</p>
<blockquote>
<div><p>The axes to draw the scalp plot on. If not provided, the
currently activated axes (i.e. <tt class="docutils literal"><span class="pre">gca()</span></tt>) will be taken</p>
</div></blockquote>
<p><strong>annotate</strong> : Boolean, optional</p>
<blockquote>
<div><p>Draw the channel names next to the channel markers.</p>
</div></blockquote>
<p><strong>vmin, vmax</strong> : float, optional</p>
<blockquote>
<div><p>The display limits for the values in <tt class="docutils literal"><span class="pre">v</span></tt>. If the data in <tt class="docutils literal"><span class="pre">v</span></tt>
contains values between -3..3 and <tt class="docutils literal"><span class="pre">vmin</span></tt> and <tt class="docutils literal"><span class="pre">vmax</span></tt> are set
to -1 and 1, all values smaller than -1 and bigger than 1 will
appear the same as -1 and 1. If not set, the maximum absolute
value in <tt class="docutils literal"><span class="pre">v</span></tt> is taken to calculate both values.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ax</strong> : Axes</p>
<blockquote class="last">
<div><p>the axes on which the plot was drawn</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#wyrm.plot.ax_colorbar" title="wyrm.plot.ax_colorbar"><tt class="xref py py-obj docutils literal"><span class="pre">ax_colorbar</span></tt></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.plot.beautify">
<tt class="descclassname">wyrm.plot.</tt><tt class="descname">beautify</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/wyrm/plot.html#beautify"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.plot.beautify" title="Permalink to this definition">¶</a></dt>
<dd><p>Set reasonable defaults matplotlib.</p>
<p>This method replaces matplotlib&#8217;s default rgb/cmyk colors with the
colarized colors. It also does:</p>
<ul class="simple">
<li>re-orders the default color cycle</li>
<li>sets the default linewidth</li>
<li>replaces the defaault &#8216;RdBu&#8217; cmap</li>
<li>sets the default cmap to &#8216;RdBu&#8217;</li>
</ul>
<p class="rubric">Examples</p>
<p>You can safely call <tt class="docutils literal"><span class="pre">beautify</span></tt> right after you&#8217;ve imported the
<tt class="docutils literal"><span class="pre">plot</span></tt> module.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">wyrm</span> <span class="kn">import</span> <span class="n">plot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="o">.</span><span class="n">beautify</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.plot.calc_centered_grid">
<tt class="descclassname">wyrm.plot.</tt><tt class="descname">calc_centered_grid</tt><big>(</big><em>cols_list</em>, <em>hpad=0.05</em>, <em>vpad=0.05</em><big>)</big><a class="reference internal" href="../_modules/wyrm/plot.html#calc_centered_grid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.plot.calc_centered_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates a centered grid of Rectangles and their positions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>cols_list</strong> : [int]</p>
<blockquote>
<div><p>List of ints. Every entry represents a row with as many channels
as the value.</p>
</div></blockquote>
<p><strong>hpad</strong> : float, optional</p>
<blockquote>
<div><p>The amount of horizontal padding (default: 0.05).</p>
</div></blockquote>
<p><strong>vpad</strong> : float, optional</p>
<blockquote>
<div><p>The amount of vertical padding (default: 0.05).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>[[float, float, float, float]]</strong> :</p>
<blockquote class="last">
<div><p>A list of all rectangle positions in the form of [xi, xy, width,
height] sorted from top left to bottom right.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Calculates a centered grid with 3 rows of 4, 3 and 2 columns</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">calc_centered_grid</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
<p>Calculates a centered grid with more padding</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">calc_centered_grid</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="n">hpad</span><span class="o">=.</span><span class="mi">1</span><span class="p">,</span> <span class="n">vpad</span><span class="o">=.</span><span class="mi">75</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.plot.get_channelpos">
<tt class="descclassname">wyrm.plot.</tt><tt class="descname">get_channelpos</tt><big>(</big><em>channame</em><big>)</big><a class="reference internal" href="../_modules/wyrm/plot.html#get_channelpos"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.plot.get_channelpos" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the x/y position of a channel.</p>
<p>This method calculates the stereographic projection of a channel
from <tt class="docutils literal"><span class="pre">CHANNEL_10_20</span></tt>, suitable for a scalp plot.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>channame</strong> : str</p>
<blockquote>
<div><p>Name of the channel, the search is case insensitive.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>x, y</strong> : float or None</p>
<blockquote class="last">
<div><p>The projected point on the plane if the point is known,
otherwise <tt class="docutils literal"><span class="pre">None</span></tt></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="o">.</span><span class="n">get_channelpos</span><span class="p">(</span><span class="s">&#39;C2&#39;</span><span class="p">)</span>
<span class="go">(0.1720792096741632, 0.0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># the channels are case insensitive</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="o">.</span><span class="n">get_channelpos</span><span class="p">(</span><span class="s">&#39;c2&#39;</span><span class="p">)</span>
<span class="go">(0.1720792096741632, 0.0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># lookup for an invalid channel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="o">.</span><span class="n">get_channelpos</span><span class="p">(</span><span class="s">&#39;foo&#39;</span><span class="p">)</span>
<span class="go">None</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.plot.interpolate_2d">
<tt class="descclassname">wyrm.plot.</tt><tt class="descname">interpolate_2d</tt><big>(</big><em>x</em>, <em>y</em>, <em>z</em><big>)</big><a class="reference internal" href="../_modules/wyrm/plot.html#interpolate_2d"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.plot.interpolate_2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate missing points on a plane.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x, y, z</strong> : equally long lists of floats</p>
<blockquote>
<div><p>1d arrays defining points like <tt class="docutils literal"><span class="pre">p[x,</span> <span class="pre">y]</span> <span class="pre">=</span> <span class="pre">z</span></tt></p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>X, Y, Z</strong> : 1d array, 1d array, 2d array</p>
<blockquote class="last">
<div><p><tt class="docutils literal"><span class="pre">Z</span></tt> is a 2d array <tt class="docutils literal"><span class="pre">[min(x)..max(x),</span> <span class="pre">[min(y)..max(y)]</span></tt> with
the interpolated values as values.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="wyrm.plot.plot_channels">
<tt class="descclassname">wyrm.plot.</tt><tt class="descname">plot_channels</tt><big>(</big><em>dat</em>, <em>chanaxis=-1</em>, <em>otheraxis=-2</em><big>)</big><a class="reference internal" href="../_modules/wyrm/plot.html#plot_channels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.plot.plot_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot all channels for a continuous.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dat</strong> : Data</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="wyrm.plot.plot_scalp">
<tt class="descclassname">wyrm.plot.</tt><tt class="descname">plot_scalp</tt><big>(</big><em>v</em>, <em>channels</em>, <em>levels=25</em>, <em>norm=None</em>, <em>ticks=None</em>, <em>annotate=True</em>, <em>position=None</em><big>)</big><a class="reference internal" href="../_modules/wyrm/plot.html#plot_scalp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.plot.plot_scalp" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots the values &#8216;v&#8217; for channels &#8216;channels&#8217; on a scalp.</p>
<p>Calculates the interpolation of the values v for the corresponding
channels &#8216;channels&#8217; and plots it as a contour plot on a scalp. The
degree of gradients as well as the the appearance of the color bar
can be adjusted.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>v</strong> : [value]</p>
<blockquote>
<div><p>List containing the values of the channels.</p>
</div></blockquote>
<p><strong>channels</strong> : [String]</p>
<blockquote>
<div><p>List containing the channel names.</p>
</div></blockquote>
<p><strong>levels</strong> : int, optional</p>
<blockquote>
<div><p>The number of automatically created levels in the contour plot
(default: 25).</p>
</div></blockquote>
<p><strong>colormap</strong> : matplotlib.colors.colormap, optional</p>
<blockquote>
<div><p>A colormap to define the color transitions (default: a
blue-white-red colormap).</p>
</div></blockquote>
<p><strong>norm</strong> : matplotlib.colors.norm, optional</p>
<blockquote>
<div><p>A norm to define the min and max values (default: &#8216;None&#8217;, values
from -10 to 10 are assumed).</p>
</div></blockquote>
<p><strong>ticks</strong> : array([ints]), optional</p>
<blockquote>
<div><p>An array with values to define the ticks on the colorbar
(default: &#8216;None&#8217;, 3 ticks at -10, 0 and 10 are displayed).</p>
</div></blockquote>
<p><strong>annotate</strong> : Boolean, optional</p>
<blockquote>
<div><p>Flag to switch channel annotations on or off (default: True).</p>
</div></blockquote>
<p><strong>position</strong> : [x, y, width, height], optional</p>
<blockquote>
<div><p>A Rectangle that limits the plot to its boundaries (default:
None).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>(Matplotlib.Axes, Matplotlib.Axes)</strong> :</p>
<blockquote class="last">
<div><p>Returns a pair of Matplotlib.Axes. The first contains the
plotted scalp, the second the corresponding colorbar.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Plots the values v for channels &#8216;channels&#8217; on a scalp</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">plot_scalp</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">channels</span><span class="p">)</span>
</pre></div>
</div>
<p>This plot has finer gradients through increasing the levels to 50.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">plot_scalp</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">channels</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
</pre></div>
</div>
<p>This plot has a norm and ticks from 0 to 10</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">clip</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot_scalp</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">channels</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">ticks</span><span class="o">=</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.plot.plot_scalp_ti">
<tt class="descclassname">wyrm.plot.</tt><tt class="descname">plot_scalp_ti</tt><big>(</big><em>v</em>, <em>channels</em>, <em>data</em>, <em>interval</em>, <em>scale_ti=0.1</em>, <em>levels=25</em>, <em>colormap=None</em>, <em>norm=None</em>, <em>ticks=None</em>, <em>annotate=True</em>, <em>position=None</em><big>)</big><a class="reference internal" href="../_modules/wyrm/plot.html#plot_scalp_ti"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.plot.plot_scalp_ti" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots a scalp with channels on top</p>
<p>Plots the values v for channels &#8216;channels&#8217; on a scalp as a contour
plot. Additionaly plots the channels in channels_ti as a
timeinterval on top of the scalp plot. The individual channels are
placed over their position on the scalp.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>v</strong> : [value]</p>
<blockquote>
<div><p>List containing the values of the channels.</p>
</div></blockquote>
<p><strong>channels</strong> : [String]</p>
<blockquote>
<div><p>List containing the channel names.</p>
</div></blockquote>
<p><strong>data</strong> : wyrm.types.Data</p>
<blockquote>
<div><p>Data object containing the continuous data for the overlaying
timeinterval plots.</p>
</div></blockquote>
<p><strong>interval</strong> : [begin, end)</p>
<blockquote>
<div><p>Tuple of ints to specify the range of the overlaying
timeinterval plots.</p>
</div></blockquote>
<p><strong>scale_ti</strong> : float, optional</p>
<blockquote>
<div><p>The percentage to scale the overlaying timeinterval plots
(default: 0.1).</p>
</div></blockquote>
<p><strong>levels</strong> : int, optional</p>
<blockquote>
<div><p>The number of automatically created levels in the contour plot
(default: 25).</p>
</div></blockquote>
<p><strong>colormap</strong> : matplotlib.colors.colormap, optional</p>
<blockquote>
<div><p>A colormap to define the color transitions (default: a
blue-white-red colormap).</p>
</div></blockquote>
<p><strong>norm</strong> : matplotlib.colors.norm, optional</p>
<blockquote>
<div><p>A norm to define the min and max values. If &#8216;None&#8217;, values from
-10 to 10 are assumed (default: None).</p>
</div></blockquote>
<p><strong>ticks</strong> : array([ints]), optional</p>
<blockquote>
<div><p>An array with values to define the ticks on the colorbar
(default: None, 3  ticks at -10, 0 and 10 are displayed).</p>
</div></blockquote>
<p><strong>annotate</strong> : Boolean, optional</p>
<blockquote>
<div><p>Flag to switch channel annotations on or off (default: True).</p>
</div></blockquote>
<p><strong>position</strong> : [x, y, width, height], optional</p>
<blockquote>
<div><p>A Rectangle that limits the plot to its boundaries (default:
None).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>((Matplotlib.Axes, Matplotlib.Axes), [Matplotlib.Axes])</strong> :</p>
<blockquote class="last">
<div><p>Returns a tuple of first a tuple with the plotted scalp and its
colorbar, then a list of all on top plotted timeintervals.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="wyrm.plot.plot_spatio_temporal_r2_values">
<tt class="descclassname">wyrm.plot.</tt><tt class="descname">plot_spatio_temporal_r2_values</tt><big>(</big><em>dat</em><big>)</big><a class="reference internal" href="../_modules/wyrm/plot.html#plot_spatio_temporal_r2_values"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.plot.plot_spatio_temporal_r2_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the signed r^2 values and plot them in a heatmap.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dat</strong> : Data</p>
<blockquote class="last">
<div><p>epoched data</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="wyrm.plot.plot_spectrogram">
<tt class="descclassname">wyrm.plot.</tt><tt class="descname">plot_spectrogram</tt><big>(</big><em>spectrogram</em>, <em>freqs</em><big>)</big><a class="reference internal" href="../_modules/wyrm/plot.html#plot_spectrogram"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.plot.plot_spectrogram" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="wyrm.plot.plot_tenten">
<tt class="descclassname">wyrm.plot.</tt><tt class="descname">plot_tenten</tt><big>(</big><em>data</em>, <em>highlights=None</em>, <em>hcolors=None</em>, <em>legend=False</em>, <em>scale=True</em>, <em>reg_chans=None</em><big>)</big><a class="reference internal" href="../_modules/wyrm/plot.html#plot_tenten"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.plot.plot_tenten" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots channels on a grid system.</p>
<p>Iterates over every channel in the data structure. If the
channelname matches a channel in the tenten-system it will be
plotted in a grid of rectangles. The grid is structured like the
tenten-system itself, but in a simplified manner. The rows, in which
channels appear, are predetermined, the channels are ordered
automatically within their respective row. Areas to highlight can be
specified, those areas will be marked with colors in every
timeinterval plot.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : wyrm.types.Data</p>
<blockquote>
<div><p>Data object containing the data to plot.</p>
</div></blockquote>
<p><strong>highlights</strong> : [[int, int)]</p>
<blockquote>
<div><p>List of tuples containing the start point (included) and end
point (excluded) of each area to be highlighted (default: None).</p>
</div></blockquote>
<p><strong>hcolors</strong> : [colors], optional</p>
<blockquote>
<div><p>A list of colors to use for the highlight areas (default: None).</p>
</div></blockquote>
<p><strong>legend</strong> : Boolean, optional</p>
<blockquote>
<div><p>Flag to switch plotting of the legend on or off (default: True).</p>
</div></blockquote>
<p><strong>scale</strong> : Boolean, optional</p>
<blockquote>
<div><p>Flag to switch plotting of a scale in the top right corner of
the grid (default: True)</p>
</div></blockquote>
<p><strong>reg_chans</strong> : [regular expressions]</p>
<blockquote>
<div><p>A list of regular expressions. The plot will be limited to those
channels matching the regular expressions.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>[Matplotlib.Axes], Matplotlib.Axes</strong> :</p>
<blockquote class="last">
<div><p>Returns the plotted timeinterval axes as a list of
Matplotlib.Axes and the plotted scale as a single
Matplotlib.Axes.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Plotting of all channels within a Data object</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">plot_tenten</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p>Plotting of all channels with a highlighted area</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">plot_tenten</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">highlights</span><span class="o">=</span><span class="p">[[</span><span class="mi">200</span><span class="p">,</span> <span class="mi">400</span><span class="p">]])</span>
</pre></div>
</div>
<p>Plotting of all channels beginning with &#8216;A&#8217;</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">plot_tenten</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">reg_chans</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;A.*&#39;</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.plot.plot_timeinterval">
<tt class="descclassname">wyrm.plot.</tt><tt class="descname">plot_timeinterval</tt><big>(</big><em>data</em>, <em>r_square=None</em>, <em>highlights=None</em>, <em>hcolors=None</em>, <em>legend=True</em>, <em>reg_chans=None</em>, <em>position=None</em><big>)</big><a class="reference internal" href="../_modules/wyrm/plot.html#plot_timeinterval"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.plot.plot_timeinterval" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots a simple time interval.</p>
<p>Plots all channels of either continuous data or the mean of epoched
data into a single timeinterval plot.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : wyrm.types.Data</p>
<blockquote>
<div><p>Data object containing the data to plot.</p>
</div></blockquote>
<p><strong>r_square</strong> : [values], optional</p>
<blockquote>
<div><p>List containing r_squared values to be plotted beneath the main
plot (default: None).</p>
</div></blockquote>
<p><strong>highlights</strong> : [[int, int)]</p>
<blockquote>
<div><p>List of tuples containing the start point (included) and end
point (excluded) of each area to be highlighted (default: None).</p>
</div></blockquote>
<p><strong>hcolors</strong> : [colors], optional</p>
<blockquote>
<div><p>A list of colors to use for the highlights areas (default:
None).</p>
</div></blockquote>
<p><strong>legend</strong> : Boolean, optional</p>
<blockquote>
<div><p>Flag to switch plotting of the legend on or off (default: True).</p>
</div></blockquote>
<p><strong>reg_chans</strong> : [regular expression], optional</p>
<blockquote>
<div><p>A list of regular expressions. The plot will be limited to those
channels matching the regular expressions. (default: None).</p>
</div></blockquote>
<p><strong>position</strong> : [x, y, width, height], optional</p>
<blockquote>
<div><p>A Rectangle that limits the plot to its boundaries (default:
None).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>Matplotlib.Axes or (Matplotlib.Axes, Matplotlib.Axes)</strong> :</p>
<blockquote class="last">
<div><p>The Matplotlib.Axes corresponding to the plotted timeinterval
and, if provided, the Axes corresponding to r_squared values.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Plots all channels contained in data with a legend.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">plot_timeinterval</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p>Same as above, but without the legend.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">plot_timeinterval</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">legend</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Adds r-square values to the plot.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">plot_timeinterval</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">r_square</span><span class="o">=</span><span class="p">[</span><span class="n">values</span><span class="p">])</span>
</pre></div>
</div>
<p>Adds a highlighted area to the plot.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">plot_timeinterval</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">highlights</span><span class="o">=</span><span class="p">[[</span><span class="mi">200</span><span class="p">,</span> <span class="mi">400</span><span class="p">]])</span>
</pre></div>
</div>
<p>To specify the colors of the highlighted areas use &#8216;hcolors&#8217;.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">plot_timeinterval</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">highlights</span><span class="o">=</span><span class="p">[[</span><span class="mi">200</span><span class="p">,</span> <span class="mi">400</span><span class="p">]],</span> <span class="n">hcolors</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;red&#39;</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.plot.set_highlights">
<tt class="descclassname">wyrm.plot.</tt><tt class="descname">set_highlights</tt><big>(</big><em>highlights</em>, <em>hcolors=None</em>, <em>set_axes=None</em><big>)</big><a class="reference internal" href="../_modules/wyrm/plot.html#set_highlights"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.plot.set_highlights" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets highlights in form of vertical boxes to axes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>highlights</strong> : [(start, end)]</p>
<blockquote>
<div><p>List of tuples containing the start point (included) and end
point (excluded) of each area to be highlighted.</p>
</div></blockquote>
<p><strong>hcolors</strong> : [colors], optional</p>
<blockquote>
<div><p>A list of colors to use for the highlight areas (e.g. &#8216;b&#8217;,
&#8216;#eeefff&#8217; or [R, G, B] for R, G, B = [0..1]. If left as None the
colors blue, gree, red, cyan, magenta and yellow are used.</p>
</div></blockquote>
<p><strong>set_axes</strong> : [matplotlib.axes.Axes], optional</p>
<blockquote class="last">
<div><p>List of axes to highlights (default: None, all axes of the
current figure will be highlighted).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>To create two highlighted areas in all axes of the currently active
figure. The first area from 200ms - 300ms in blue and the second
area from 500ms - 600ms in green.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">set_highlights</span><span class="p">([[</span><span class="mi">200</span><span class="p">,</span> <span class="mi">300</span><span class="p">],</span> <span class="p">[</span><span class="mi">500</span><span class="p">,</span> <span class="mi">600</span><span class="p">]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-wyrm.processing">
<span id="wyrm-processing-module"></span><h2>wyrm.processing module<a class="headerlink" href="#module-wyrm.processing" title="Permalink to this headline">¶</a></h2>
<p>Processing toolbox methods.</p>
<p>This module contains the processing methods.</p>
<dl class="function">
<dt id="wyrm.processing.append">
<tt class="descclassname">wyrm.processing.</tt><tt class="descname">append</tt><big>(</big><em>dat</em>, <em>dat2</em>, <em>axis=0</em>, <em>extra=None</em><big>)</big><a class="reference internal" href="../_modules/wyrm/processing.html#append"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Append <tt class="docutils literal"><span class="pre">dat2</span></tt> to <tt class="docutils literal"><span class="pre">dat</span></tt>.</p>
<p>This method creates a copy of <tt class="docutils literal"><span class="pre">dat</span></tt> (with all attributes),
concatenates <tt class="docutils literal"><span class="pre">dat.data</span></tt> and <tt class="docutils literal"><span class="pre">dat2.data</span></tt> along <tt class="docutils literal"><span class="pre">axis</span></tt> as well
as <tt class="docutils literal"><span class="pre">dat.axes[axis]</span></tt> and <tt class="docutils literal"><span class="pre">dat2.axes[axis]</span></tt>. If present, it will
concatenate the attributes in <tt class="docutils literal"><span class="pre">extra</span></tt> as well and return the
result.</p>
<p>It also performs checks if the dimensions and lengths of <tt class="docutils literal"><span class="pre">data</span></tt>
and <tt class="docutils literal"><span class="pre">axes</span></tt> match and test if <tt class="docutils literal"><span class="pre">units</span></tt> and <tt class="docutils literal"><span class="pre">names</span></tt> are equal.</p>
<p>Since <tt class="docutils literal"><span class="pre">append</span></tt> cannot know how to deal with the various attributes
<tt class="docutils literal"><span class="pre">dat</span></tt> and <tt class="docutils literal"><span class="pre">dat2</span></tt> might have, it only copies the attributes of
<tt class="docutils literal"><span class="pre">dat</span></tt> and deals with the attributes it knows about, namely:
<tt class="docutils literal"><span class="pre">data</span></tt>, <tt class="docutils literal"><span class="pre">axes</span></tt>, <tt class="docutils literal"><span class="pre">names</span></tt>, and <tt class="docutils literal"><span class="pre">units</span></tt>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This method is really low level and stupid. It does not know
about markers or timeaxes, etc. it just appends two data
objects. If you want to append continuous or epoched data
consider using <a class="reference internal" href="#wyrm.processing.append_cnt" title="wyrm.processing.append_cnt"><tt class="xref py py-func docutils literal"><span class="pre">append_cnt()</span></tt></a> and <a class="reference internal" href="#wyrm.processing.append_epo" title="wyrm.processing.append_epo"><tt class="xref py py-func docutils literal"><span class="pre">append_epo()</span></tt></a>.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dat, dat2</strong> : Data</p>
<p><strong>axis</strong> : int, optional</p>
<blockquote>
<div><p>the axis along which to concatenate. The default axis (0) does
the right thing for continuous and epoched data as it
concatenates along the time- or the class-axis respectively.</p>
</div></blockquote>
<p><strong>extra</strong> : list of strings, optional</p>
<blockquote>
<div><p>a list of attributes in <tt class="docutils literal"><span class="pre">dat</span></tt> and <tt class="docutils literal"><span class="pre">dat2</span></tt> to concatenate as
well. Currently the attributes must have the types <tt class="docutils literal"><span class="pre">list</span></tt> or
<tt class="docutils literal"><span class="pre">ndarray</span></tt>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dat</strong> : Data</p>
<blockquote>
<div><p>a copy of <tt class="docutils literal"><span class="pre">dat</span></tt> with <tt class="docutils literal"><span class="pre">dat2</span></tt> appended</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>AssertionError</strong> :</p>
<blockquote>
<div><dl class="docutils">
<dt>if one of the following is true:</dt>
<dd><ul class="first last simple">
<li>the dimensions of <tt class="docutils literal"><span class="pre">.data</span></tt> do not match</li>
<li><tt class="docutils literal"><span class="pre">names</span></tt> are not equal</li>
<li><tt class="docutils literal"><span class="pre">units</span></tt> are not equal</li>
<li><tt class="docutils literal"><span class="pre">data.shape[i]</span></tt> are not equal for all i except <tt class="docutils literal"><span class="pre">i</span> <span class="pre">==</span> <span class="pre">axis</span></tt></li>
<li><tt class="docutils literal"><span class="pre">axes[i]</span></tt> are not equal for all i except <tt class="docutils literal"><span class="pre">i</span> <span class="pre">==</span> <span class="pre">axis</span></tt></li>
</ul>
</dd>
</dl>
</div></blockquote>
<p><strong>TypeError</strong> :</p>
<blockquote class="last">
<div><ul class="simple">
<li>if one of the attributes in <tt class="docutils literal"><span class="pre">extra</span></tt> does not have the same
type in <tt class="docutils literal"><span class="pre">dat</span></tt> and <tt class="docutils literal"><span class="pre">dat2</span></tt></li>
<li>if one of the attributes in <tt class="docutils literal"><span class="pre">extra</span></tt> has an unsupported type</li>
</ul>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#wyrm.processing.append_cnt" title="wyrm.processing.append_cnt"><tt class="xref py py-obj docutils literal"><span class="pre">append_cnt</span></tt></a>, <a class="reference internal" href="#wyrm.processing.append_epo" title="wyrm.processing.append_epo"><tt class="xref py py-obj docutils literal"><span class="pre">append_epo</span></tt></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># concatenate two continuous data objects, and their markers,</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># please note how the resulting marker is not correct, just</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># appended</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnt</span><span class="o">.</span><span class="n">markers</span>
<span class="go">[[0, &#39;a&#39;], [10, &#39;b&#39;]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnt2</span><span class="o">.</span><span class="n">markers</span>
<span class="go">[[20, &#39;c&#39;], [30, &#39;d&#39;]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnt</span> <span class="o">=</span> <span class="n">append</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">cnt2</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;markers&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnt</span><span class="o">.</span><span class="n">markers</span>
<span class="go">[[0, &#39;a&#39;], [10, &#39;b&#39;], [20, &#39;c&#39;], [30, &#39;d&#39;]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.append_cnt">
<tt class="descclassname">wyrm.processing.</tt><tt class="descname">append_cnt</tt><big>(</big><em>dat</em>, <em>dat2</em>, <em>timeaxis=-2</em>, <em>extra=None</em><big>)</big><a class="reference internal" href="../_modules/wyrm/processing.html#append_cnt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.append_cnt" title="Permalink to this definition">¶</a></dt>
<dd><p>Append two continuous data objects.</p>
<p>This method uses <a class="reference internal" href="#wyrm.processing.append" title="wyrm.processing.append"><tt class="xref py py-func docutils literal"><span class="pre">append()</span></tt></a> to append to continuous data
objects. It also takes care that the resulting continuous will have
a correct <tt class="docutils literal"><span class="pre">.axes[timeaxis]</span></tt>. For that it uses the <tt class="docutils literal"><span class="pre">.fs</span></tt>
attribute and the length of the data to recalculate the timeaxis.</p>
<p>If both <tt class="docutils literal"><span class="pre">dat</span></tt> and <tt class="docutils literal"><span class="pre">dat2</span></tt> have the <tt class="docutils literal"><span class="pre">markers</span></tt> attribute, the
markers will be treated properly (i.e. by moving the markers of
<tt class="docutils literal"><span class="pre">dat2</span></tt> by <tt class="docutils literal"><span class="pre">dat</span></tt> milliseconds to the right.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dat, dat2</strong> : Data</p>
<p><strong>timeaxis</strong> : int, optional</p>
<p><strong>extra: list of strings, optional</strong> :</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dat</strong> : Data</p>
<blockquote>
<div><p>the resulting combination of <tt class="docutils literal"><span class="pre">dat</span></tt> and <tt class="docutils literal"><span class="pre">dat2</span></tt></p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>AssertionError</strong> :</p>
<blockquote class="last">
<div><p>if at least one of the <tt class="docutils literal"><span class="pre">Data</span></tt> parameters has not the <tt class="docutils literal"><span class="pre">.fs</span></tt>
attribute or if the <tt class="docutils literal"><span class="pre">.fs</span></tt> attributes are not equal.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#wyrm.processing.append" title="wyrm.processing.append"><tt class="xref py py-obj docutils literal"><span class="pre">append</span></tt></a>, <a class="reference internal" href="#wyrm.processing.append_epo" title="wyrm.processing.append_epo"><tt class="xref py py-obj docutils literal"><span class="pre">append_epo</span></tt></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">cnt</span><span class="o">.</span><span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">[0, 1, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnt2</span><span class="o">.</span><span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">[0, 1, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnt</span><span class="o">.</span><span class="n">fs</span>
<span class="go">1000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnt</span> <span class="o">=</span> <span class="n">append_cnt</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">cnt2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnt</span><span class="o">.</span><span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">[0, 1, 2, 3, 4, 5]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.append_epo">
<tt class="descclassname">wyrm.processing.</tt><tt class="descname">append_epo</tt><big>(</big><em>dat</em>, <em>dat2</em>, <em>classaxis=0</em>, <em>extra=None</em><big>)</big><a class="reference internal" href="../_modules/wyrm/processing.html#append_epo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.append_epo" title="Permalink to this definition">¶</a></dt>
<dd><p>Append two epoched data objects.</p>
<p>This method just calls <a class="reference internal" href="#wyrm.processing.append" title="wyrm.processing.append"><tt class="xref py py-func docutils literal"><span class="pre">append()</span></tt></a>. In addition to the errors
<a class="reference internal" href="#wyrm.processing.append" title="wyrm.processing.append"><tt class="xref py py-func docutils literal"><span class="pre">append()</span></tt></a> might throw, it will raise an error if the
<tt class="docutils literal"><span class="pre">class_names</span></tt> are not equal if present in both objects.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dat, dat2</strong> : Data</p>
<p><strong>classaxis</strong> : int, optional</p>
<p><strong>extra</strong> : list of strings, optional</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dat</strong> : Data</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>ValueError</strong> :</p>
<blockquote class="last">
<div><p>if both objects have a <tt class="docutils literal"><span class="pre">class_names</span></tt> attribute, they must be
equal</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#wyrm.processing.append" title="wyrm.processing.append"><tt class="xref py py-obj docutils literal"><span class="pre">append</span></tt></a>, <a class="reference internal" href="#wyrm.processing.append_cnt" title="wyrm.processing.append_cnt"><tt class="xref py py-obj docutils literal"><span class="pre">append_cnt</span></tt></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">epo</span> <span class="o">=</span> <span class="n">append_epo</span><span class="p">(</span><span class="n">epo</span><span class="p">,</span> <span class="n">epo2</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.apply_csp">
<tt class="descclassname">wyrm.processing.</tt><tt class="descname">apply_csp</tt><big>(</big><em>epo, filt, columns=[0, -1]</em><big>)</big><a class="reference internal" href="../_modules/wyrm/processing.html#apply_csp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.apply_csp" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the CSP filter.</p>
<p>Apply the spacial CSP filter to the epoched data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>epo</strong> : epoched <tt class="docutils literal"><span class="pre">Data</span></tt> object</p>
<blockquote>
<div><p>this method relies on the <tt class="docutils literal"><span class="pre">epo</span></tt> to have three dimensions in
the following order: class, time, channel</p>
</div></blockquote>
<p><strong>filt</strong> : 2d array</p>
<blockquote>
<div><p>the CSP filter (i.e. the <tt class="docutils literal"><span class="pre">v</span></tt> return value from
<a class="reference internal" href="#wyrm.processing.calculate_csp" title="wyrm.processing.calculate_csp"><tt class="xref py py-func docutils literal"><span class="pre">calculate_csp()</span></tt></a>)</p>
</div></blockquote>
<p><strong>columns</strong> : array of ints, optional</p>
<blockquote>
<div><p>the columns of the filter to use. The default is the first and
the last one.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>epo</strong> : epoched <tt class="docutils literal"><span class="pre">Data</span></tt> object</p>
<blockquote class="last">
<div><p>The channels from the original have been replaced with the new
virtual CSP channels.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#wyrm.processing.calculate_csp" title="wyrm.processing.calculate_csp"><tt class="xref py py-func docutils literal"><span class="pre">calculate_csp()</span></tt></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">w</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">calculate_csp</span><span class="p">(</span><span class="n">epo</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">epo</span> <span class="o">=</span> <span class="n">apply_csp</span><span class="p">(</span><span class="n">epo</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.calculate_classwise_average">
<tt class="descclassname">wyrm.processing.</tt><tt class="descname">calculate_classwise_average</tt><big>(</big><em>dat</em>, <em>classaxis=0</em><big>)</big><a class="reference internal" href="../_modules/wyrm/processing.html#calculate_classwise_average"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.calculate_classwise_average" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the classwise average.</p>
<p>This method calculates the average continuous per class for all
classes defined in the <tt class="docutils literal"><span class="pre">dat</span></tt>. In other words, if you have two
different classes, with many continuous data per class, this method
will calculate the average time course for each class and channel.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dat</strong> : Data</p>
<blockquote>
<div><p>an epoched Data object with a <tt class="docutils literal"><span class="pre">.class_names</span></tt> attribute.</p>
</div></blockquote>
<p><strong>classaxis</strong> : int, optional</p>
<blockquote>
<div><p>the axis along which to calculate the average</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dat</strong> : Data</p>
<blockquote>
<div><p>copy of <tt class="docutils literal"><span class="pre">dat</span></tt> a witht the <tt class="docutils literal"><span class="pre">classaxis</span></tt> dimension reduced to
the number of different classes.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>AssertionError</strong> :</p>
<blockquote class="last">
<div><p>if the <tt class="docutils literal"><span class="pre">dat</span></tt> has no <tt class="docutils literal"><span class="pre">.class_names</span></tt> attribute.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Split existing continuous data into two classes and calculate the
average for each class.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mrk_def</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;std&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s">&#39;S </span><span class="si">%2i</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">)],</span>
<span class="gp">... </span>           <span class="s">&#39;dev&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s">&#39;S </span><span class="si">%2i</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">17</span><span class="p">)]</span>
<span class="gp">... </span>          <span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">epo</span> <span class="o">=</span> <span class="n">misc</span><span class="o">.</span><span class="n">segment_dat</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">mrk_def</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">660</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">avg_epo</span> <span class="o">=</span> <span class="n">calculate_classwise_average</span><span class="p">(</span><span class="n">epo</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">(</span><span class="n">avg_epo</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">(</span><span class="n">avg_epo</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.calculate_csp">
<tt class="descclassname">wyrm.processing.</tt><tt class="descname">calculate_csp</tt><big>(</big><em>epo</em>, <em>classes=None</em><big>)</big><a class="reference internal" href="../_modules/wyrm/processing.html#calculate_csp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.calculate_csp" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the Common Spatial Pattern (CSP) for two classes.</p>
<p>This method calculates the CSP and the corresponding filters. Use
the columns of the patterns and filters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>epo</strong> : epoched Data object</p>
<blockquote>
<div><p>this method relies on the <tt class="docutils literal"><span class="pre">epo</span></tt> to have three dimensions in
the following order: class, time, channel</p>
</div></blockquote>
<p><strong>classes</strong> : list of two ints, optional</p>
<blockquote>
<div><p>If <tt class="docutils literal"><span class="pre">None</span></tt> the first two different class indices found in
<tt class="docutils literal"><span class="pre">epo.axes[0]</span></tt> are chosen automatically otherwise the class
indices can be manually chosen by setting <tt class="docutils literal"><span class="pre">classes</span></tt></p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>v</strong> : 2d array</p>
<blockquote>
<div><p>the sorted spacial filters</p>
</div></blockquote>
<p><strong>a</strong> : 2d array</p>
<blockquote>
<div><p>the sorted spacial patterns. Column i of a represents the
pattern of the filter in column i of v.</p>
</div></blockquote>
<p><strong>d</strong> : 1d array</p>
<blockquote>
<div><p>the variances of the components</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>AssertionError :</strong> :</p>
<blockquote class="last">
<div><dl class="docutils">
<dt>If:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">classes</span></tt> is not <tt class="docutils literal"><span class="pre">None</span></tt> and has less than two elements</li>
<li><tt class="docutils literal"><span class="pre">classes</span></tt> is not <tt class="docutils literal"><span class="pre">None</span></tt> and the first two elements are
not found in the <tt class="docutils literal"><span class="pre">epo</span></tt></li>
<li><tt class="docutils literal"><span class="pre">classes</span></tt> is <tt class="docutils literal"><span class="pre">None</span></tt> but there are less than two
different classes in the <tt class="docutils literal"><span class="pre">epo</span></tt></li>
</ul>
</dd>
</dl>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#wyrm.processing.apply_csp" title="wyrm.processing.apply_csp"><tt class="xref py py-func docutils literal"><span class="pre">apply_csp()</span></tt></a>, <a class="reference internal" href="#wyrm.processing.calculate_spoc" title="wyrm.processing.calculate_spoc"><tt class="xref py py-func docutils literal"><span class="pre">calculate_spoc()</span></tt></a></p>
</div>
<p class="rubric">References</p>
<p><a class="reference external" href="http://en.wikipedia.org/wiki/Common_spatial_pattern">http://en.wikipedia.org/wiki/Common_spatial_pattern</a></p>
<p class="rubric">Examples</p>
<p>Calculate the CSP for the first two classes:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">w</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">calculate_csp</span><span class="p">(</span><span class="n">epo</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Apply the first two and the last two columns of the sorted</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># filter to the data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filtered</span> <span class="o">=</span> <span class="n">apply_csp</span><span class="p">(</span><span class="n">epo</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># You&#39;ll probably want to get the log-variance along the time</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># axis, this should result in four numbers (one for each</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># channel)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filtered</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">filtered</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
<p>Select two classes manually:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">w</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">calculate_csp</span><span class="p">(</span><span class="n">epo</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.calculate_signed_r_square">
<tt class="descclassname">wyrm.processing.</tt><tt class="descname">calculate_signed_r_square</tt><big>(</big><em>dat</em>, <em>classaxis=0</em><big>)</big><a class="reference internal" href="../_modules/wyrm/processing.html#calculate_signed_r_square"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.calculate_signed_r_square" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the signed r**2 values.</p>
<p>This method calculates the signed r**2 values over the epochs of the
<tt class="docutils literal"><span class="pre">dat</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dat</strong> : Data</p>
<blockquote>
<div><p>epoched data</p>
</div></blockquote>
<p><strong>classaxis</strong> : int, optional</p>
<blockquote>
<div><p>the axis to be treatet as the classaxis</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>signed_r_square</strong> : ndarray</p>
<blockquote class="last">
<div><p>the signed r**2 values, signed_r_square has one axis less than
the <tt class="docutils literal"><span class="pre">dat</span></tt> parameter, the <tt class="docutils literal"><span class="pre">classaxis</span></tt> has been removed</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(400, 100, 64)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">calculate_signed_r_square</span><span class="p">(</span><span class="n">dat</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(100, 64)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.calculate_spoc">
<tt class="descclassname">wyrm.processing.</tt><tt class="descname">calculate_spoc</tt><big>(</big><em>epo</em><big>)</big><a class="reference internal" href="../_modules/wyrm/processing.html#calculate_spoc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.calculate_spoc" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute source power co-modulation analysis (SPoC)</p>
<p>Computes spatial filters that optimize the co-modulation (here
covariance) between the epoch-wise variance (as a proxy for spectral
power) and a given target signal.</p>
<p>This SPoc function returns a full set of components (i.e. filters
and patterns) of which the first component maximizes the
co-modulation (i.e. positive covariance) and the last component
minimizes it (i.e. maximizes negative covariance).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Since the covariance is optimized, it may be affected by
outliers in the data (i.e. trials/epochs with very large
variance that is due to artifacts). Please remove be sure to
remove these epochs if possible before calling this function!</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>epo</strong> : epoched Data oject</p>
<blockquote>
<div><p>this method relies on the <tt class="docutils literal"><span class="pre">epo</span></tt> to have three dimensions in
the following order: class, time, channel. The data in epo
should be band-pass filtered for the frequency band of interest.
The values of the target variable (i.e. <tt class="docutils literal"><span class="pre">epo.axes[0]</span></tt>) must be
present in epo.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>v</strong> : 2d array</p>
<blockquote>
<div><p>The spatial filters optimized by the <tt class="docutils literal"><span class="pre">SPoC_lambda</span></tt> algorithm.
Each column in the matrix is a filter.</p>
</div></blockquote>
<p><strong>a</strong> : 2d array</p>
<blockquote>
<div><p>The spatial activation patterns that correspond to the filters
in <tt class="docutils literal"><span class="pre">v</span></tt>. Each column is a spatial pattern. when visualizing the
SPoC components as scalp maps, plot the spatial patterns and not
the filters. See also <a class="reference internal" href="#r2" id="id1">[R2]</a>.</p>
</div></blockquote>
<p><strong>d</strong> : 1d array</p>
<blockquote class="last">
<div><p>The lambda values that correspond to the filters/patterns in
<tt class="docutils literal"><span class="pre">v</span></tt> and <tt class="docutils literal"><span class="pre">a</span></tt>, sorted from largest (positive covariance) to
smallest (negative covariance).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#wyrm.processing.calculate_csp" title="wyrm.processing.calculate_csp"><tt class="xref py py-func docutils literal"><span class="pre">calculate_csp()</span></tt></a></p>
</div>
<p class="rubric">Notes</p>
<p>SPoC assumes that there is a linear relationship between a measured
target signal and the dynamics of the spectral power of an
oscillatory source that is hidden in the data. The target signal my
be a stimulus property (e.g. intensity, frequency, color, ...), a
behavioral measure (e.g. reaction times, ratings, ...) , or any
other uni-variate signal of interest. The time-course of spectral
power of the oscillatory source signal is approximated by variance
across small time segments (epochs). Thus, if the power of a
specific frequency band is investigated, the input signals must be
band-passed filtered before they are segmented into epochs and given
to this function. This method implements <tt class="docutils literal"><span class="pre">SPoC_lambda</span></tt>, presented
in <a class="reference internal" href="#r1" id="id2">[R1]</a>. Thus, source activity is extracted from the input data via
spatial filtering. The spatial filters are optimized such that the
epoch-wise variance maximally covaries with the given target signal
<tt class="docutils literal"><span class="pre">z</span></tt>.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R1]</td><td><em>(<a class="fn-backref" href="#id2">1</a>, <a class="fn-backref" href="#id3">2</a>)</em> S. Dähne, F. C. Meinecke, S. Haufe, J. Höhne, M. Tangermann,
K. R. Müller, V. V. Nikulin &#8220;SPoC: a novel framework for
relating the amplitude of neuronal oscillations to behaviorally
relevant parameters&#8221;, NeuroImage, 86(0):111-122, 2014</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R2]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id4">2</a>)</em> S. Haufe, F. Meinecke, K. Görgen, S. Dähne, J. Haynes, B.
Blankertz, F. Biessmann, &#8220;On the interpretation of weight
vectors of linear models in multivariate neuroimaging&#8221;,
NeuroImage, 87:96-110, 2014</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Split data in training and test set</p>
<p>Calculate SPoC:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">w</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">calculate_spoc</span><span class="p">(</span><span class="n">epo</span><span class="p">)</span>
</pre></div>
</div>
<p>Identify the components with strongest co-modulation by checking the
covariance values stored in <tt class="docutils literal"><span class="pre">d</span></tt>. If there is positive covariance
with the target variable it will be the first, otherwise the last:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="n">w</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>Apply the filter(s) to the test data:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">filtered</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.clear_markers">
<tt class="descclassname">wyrm.processing.</tt><tt class="descname">clear_markers</tt><big>(</big><em>dat</em>, <em>timeaxis=-2</em><big>)</big><a class="reference internal" href="../_modules/wyrm/processing.html#clear_markers"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.clear_markers" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove markers that are outside of the <tt class="docutils literal"><span class="pre">dat</span></tt> time interval.</p>
<p>This method removes the markers that are out of the time interval
described in the <tt class="docutils literal"><span class="pre">dat</span></tt> object.</p>
<p>If the <tt class="docutils literal"><span class="pre">dat</span></tt> object has not <tt class="docutils literal"><span class="pre">markers</span></tt> attribute or the markers
are empty, simply a copy of <tt class="docutils literal"><span class="pre">dat</span></tt> is returned.</p>
<p>If <tt class="docutils literal"><span class="pre">dat.data</span></tt> is empty, but has markers, all markers are removed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dat</strong> : Data</p>
<p><strong>timeaxis</strong> : int, optional</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dat</strong> : Data</p>
<blockquote>
<div><p>a copy of the Data object, with the respective markers removed</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>AssertionError</strong> :</p>
<blockquote class="last">
<div><p>if the given <tt class="docutils literal"><span class="pre">dat</span></tt> has not <tt class="docutils literal"><span class="pre">fs</span></tt> attribute</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">array([-5., -4., -3., -2., -1.,  0.,  1.,  2.,  3.,  4.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">fs</span>
<span class="go">1000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">markers</span>
<span class="go">[[-6, &#39;a&#39;], [-5, &#39;b&#39;], [0, &#39;c&#39;], [4.9999, &#39;d&#39;], [5, &#39;e&#39;]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="n">clear_markers</span><span class="p">(</span><span class="n">dat</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">markers</span>
<span class="go">[[-5, &#39;b&#39;], [0, &#39;c&#39;], [4.9999, &#39;d&#39;]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.correct_for_baseline">
<tt class="descclassname">wyrm.processing.</tt><tt class="descname">correct_for_baseline</tt><big>(</big><em>dat</em>, <em>ival</em>, <em>timeaxis=-2</em><big>)</big><a class="reference internal" href="../_modules/wyrm/processing.html#correct_for_baseline"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.correct_for_baseline" title="Permalink to this definition">¶</a></dt>
<dd><p>Subtract the baseline.</p>
<p>For each epoch and channel in the given dat, this method calculates
the average value for the given interval and subtracts this value
from the channel data within this epoch and channel.</p>
<p>This method generalizes to dats with more than 3 dimensions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dat</strong> : Dat</p>
<p><strong>ival</strong> : array of two floats</p>
<blockquote>
<div><p>the start and stop borders in milli seconds. the left border is
included, the right border is not: <tt class="docutils literal"><span class="pre">[start,</span> <span class="pre">stop)</span></tt>.
<tt class="docutils literal"><span class="pre">ival[0]</span></tt> must fit into <tt class="docutils literal"><span class="pre">dat.axes[timeaxis]</span></tt> and
<tt class="docutils literal"><span class="pre">ival[0]</span> <span class="pre">&lt;=</span> <span class="pre">ival[1]</span></tt>.</p>
</div></blockquote>
<p><strong>timeaxis</strong> : int, optional</p>
<blockquote>
<div><p>the axis along which to correct for the baseline</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dat</strong> : Dat</p>
<blockquote>
<div><p>a copy of <tt class="docutils literal"><span class="pre">dat</span></tt> with the averages of the intervals subtracted.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>AssertionError</strong> :</p>
<blockquote class="last">
<div><p>If the left border of <tt class="docutils literal"><span class="pre">ival</span></tt> is outside of
<tt class="docutils literal"><span class="pre">dat.axes[timeaxis]</span></tt> or if <tt class="docutils literal"><span class="pre">ival[1]</span> <span class="pre">&lt;</span> <span class="pre">ival[0]</span></tt>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-obj docutils literal"><span class="pre">numpy.average</span></tt>, <tt class="xref py py-obj docutils literal"><span class="pre">numpy.expand_dims</span></tt></p>
</div>
<p class="rubric">Notes</p>
<p>The Algorithm calculates the average(s) along the <tt class="docutils literal"><span class="pre">timeaxis</span></tt> within
the given interval. The resulting array has one dimension less
than the original one (the elements on <tt class="docutils literal"><span class="pre">timeaxis</span></tt> where reduced).</p>
<p>The resulting avgarray is then subtracted from the original data. To
match the shape, a new axis is created on <tt class="docutils literal"><span class="pre">timeaxis</span></tt> of avgarray.
And the shapes are then matched via numpy&#8217;s broadcasting.</p>
<p class="rubric">Examples</p>
<p>Remove the baselines for the interval <tt class="docutils literal"><span class="pre">[100,</span> <span class="pre">0)</span></tt></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="n">correct_for_baseline</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.create_feature_vectors">
<tt class="descclassname">wyrm.processing.</tt><tt class="descname">create_feature_vectors</tt><big>(</big><em>dat</em>, <em>classaxis=0</em><big>)</big><a class="reference internal" href="../_modules/wyrm/processing.html#create_feature_vectors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.create_feature_vectors" title="Permalink to this definition">¶</a></dt>
<dd><p>Create feature vectors from epoched data.</p>
<p>This method flattens a <tt class="docutils literal"><span class="pre">Data</span></tt> objects down to 2 dimensions: the
first one for the classes and the second for the feature vectors.
All surplus dimensions of the <tt class="docutils literal"><span class="pre">dat</span></tt> argument are clashed into the
appropriate class.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dat</strong> : Data</p>
<p><strong>classaxis</strong> : int, optional</p>
<blockquote>
<div><p>the index of the class axis</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dat</strong> : Data</p>
<blockquote class="last">
<div><p>a copy of <tt class="docutils literal"><span class="pre">dat</span></tt> with reshaped to 2 dimensions and with the
classaxis moved to dimension 0</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(300, 2, 64)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="n">create_feature_vectors</span><span class="p">(</span><span class="n">dat</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(300, 128)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.filtfilt">
<tt class="descclassname">wyrm.processing.</tt><tt class="descname">filtfilt</tt><big>(</big><em>dat</em>, <em>b</em>, <em>a</em>, <em>timeaxis=-2</em><big>)</big><a class="reference internal" href="../_modules/wyrm/processing.html#filtfilt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.filtfilt" title="Permalink to this definition">¶</a></dt>
<dd><p>A forward-backward filter.</p>
<p>Filter data twice, once forward and once backwards, using the filter
defined by the filter coefficients.</p>
<p>This method mainly delegates the call to
<tt class="xref py py-func docutils literal"><span class="pre">scipy.signal.filtfilt()</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dat</strong> : Data</p>
<blockquote>
<div><p>the data to be filtered</p>
</div></blockquote>
<p><strong>b</strong> : 1-d array</p>
<blockquote>
<div><p>the numerator coefficient vector</p>
</div></blockquote>
<p><strong>a</strong> : 1-d array</p>
<blockquote>
<div><p>the denominator coefficient vector</p>
</div></blockquote>
<p><strong>timeaxis</strong> : int, optional</p>
<blockquote>
<div><p>the axes in <tt class="docutils literal"><span class="pre">data</span></tt> to filter along to</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dat</strong> : Data</p>
<blockquote class="last">
<div><p>the filtered output</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#wyrm.processing.lfilter" title="wyrm.processing.lfilter"><tt class="xref py py-func docutils literal"><span class="pre">lfilter()</span></tt></a></p>
</div>
<p class="rubric">Examples</p>
<p>Generate and use a Butterworth bandpass filter for complete
(off-line data):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># the sampling frequency of our data in Hz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">fs</span>
<span class="go">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># calculate the nyquist frequency</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fn</span> <span class="o">=</span> <span class="n">dat</span><span class="o">.</span><span class="n">fs</span> <span class="o">/</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># the desired low and high frequencies in Hz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f_low</span><span class="p">,</span> <span class="n">f_high</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">13</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># the order of the filter</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">butter_ord</span> <span class="o">=</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># calculate the filter coefficients</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">butter</span><span class="p">(</span><span class="n">butter_ord</span><span class="p">,</span> <span class="p">[</span><span class="n">f_low</span> <span class="o">/</span> <span class="n">fn</span><span class="p">,</span> <span class="n">f_high</span> <span class="o">/</span> <span class="n">fn</span><span class="p">],</span> <span class="n">btype</span><span class="o">=</span><span class="s">&#39;band&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filtered</span> <span class="o">=</span> <span class="n">filtfilt</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.jumping_means">
<tt class="descclassname">wyrm.processing.</tt><tt class="descname">jumping_means</tt><big>(</big><em>dat</em>, <em>ivals</em>, <em>timeaxis=-2</em><big>)</big><a class="reference internal" href="../_modules/wyrm/processing.html#jumping_means"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.jumping_means" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the jumping means.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dat</strong> : Data</p>
<p><strong>ivals</strong> : array of [float, float]</p>
<blockquote>
<div><p>the intervals for which to calculate the means. Start is
included end is not (like <tt class="docutils literal"><span class="pre">[start,</span> <span class="pre">end)</span></tt>).</p>
</div></blockquote>
<p><strong>timeaxis</strong> : int, optional</p>
<blockquote>
<div><p>the axis along which to calculate the jumping means</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dat</strong> : Data</p>
<blockquote class="last">
<div><p>copy of <tt class="docutils literal"><span class="pre">dat</span></tt> with the jumping means along the <tt class="docutils literal"><span class="pre">timeaxis</span></tt>.
<tt class="docutils literal"><span class="pre">dat.name[timeaxis]</span></tt> and <tt class="docutils literal"><span class="pre">dat.axes[timeaxis]</span></tt> Are modified
too to reflect the intervals used for the data points.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.lda_apply">
<tt class="descclassname">wyrm.processing.</tt><tt class="descname">lda_apply</tt><big>(</big><em>fv</em>, <em>clf</em><big>)</big><a class="reference internal" href="../_modules/wyrm/processing.html#lda_apply"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.lda_apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply feature vector to LDA classifier.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fv</strong> : <tt class="docutils literal"><span class="pre">Data</span></tt> object</p>
<blockquote>
<div><p>the feature vector must have a 2 dimensional data, the first
dimension being the class axis.</p>
</div></blockquote>
<p><strong>clf</strong> : (1d array, float)</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> : 1d array</p>
<blockquote class="last">
<div><p>The projection of the data on the hyperplane.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#wyrm.processing.lda_train" title="wyrm.processing.lda_train"><tt class="xref py py-obj docutils literal"><span class="pre">lda_train</span></tt></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span> <span class="o">=</span> <span class="n">lda_train</span><span class="p">(</span><span class="n">fv_train</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">lda_apply</span><span class="p">(</span><span class="n">fv_test</span><span class="p">,</span> <span class="n">clf</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.lda_train">
<tt class="descclassname">wyrm.processing.</tt><tt class="descname">lda_train</tt><big>(</big><em>fv</em>, <em>shrink=True</em><big>)</big><a class="reference internal" href="../_modules/wyrm/processing.html#lda_train"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.lda_train" title="Permalink to this definition">¶</a></dt>
<dd><p>Train the LDA classifier.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fv</strong> : <tt class="docutils literal"><span class="pre">Data</span></tt> object</p>
<blockquote>
<div><p>the feature vector must have 2 dimensional data, the first
dimension being the class axis.</p>
</div></blockquote>
<p><strong>shrink</strong> : Boolean, optional</p>
<blockquote>
<div><p>use shrinkage</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>w</strong> : 1d array</p>
<p class="last"><strong>b</strong> : float</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#wyrm.processing.lda_apply" title="wyrm.processing.lda_apply"><tt class="xref py py-obj docutils literal"><span class="pre">lda_apply</span></tt></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span> <span class="o">=</span> <span class="n">lda_train</span><span class="p">(</span><span class="n">fv_train</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">lda_apply</span><span class="p">(</span><span class="n">fv_test</span><span class="p">,</span> <span class="n">clf</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.lfilter">
<tt class="descclassname">wyrm.processing.</tt><tt class="descname">lfilter</tt><big>(</big><em>dat</em>, <em>b</em>, <em>a</em>, <em>zi=None</em>, <em>timeaxis=-2</em><big>)</big><a class="reference internal" href="../_modules/wyrm/processing.html#lfilter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.lfilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter data using the filter defined by the filter coefficients.</p>
<p>This method mainly delegates the call to
<tt class="xref py py-func docutils literal"><span class="pre">scipy.signal.lfilter()</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dat</strong> : Data</p>
<blockquote>
<div><p>the data to be filtered</p>
</div></blockquote>
<p><strong>b</strong> : 1-d array</p>
<blockquote>
<div><p>the numerator coefficient vector</p>
</div></blockquote>
<p><strong>a</strong> : 1-d array</p>
<blockquote>
<div><p>the denominator coefficient vector</p>
</div></blockquote>
<p><strong>zi</strong> : nd array, optional</p>
<blockquote>
<div><p>the initial conditions for the filter delay. If zi is <tt class="docutils literal"><span class="pre">None</span></tt>
or not given, initial rest is assumed.</p>
</div></blockquote>
<p><strong>timeaxis</strong> : int, optional</p>
<blockquote>
<div><p>the axes in <tt class="docutils literal"><span class="pre">data</span></tt> to filter along to</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dat</strong> : Data</p>
<blockquote class="last">
<div><p>the filtered output</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#wyrm.processing.filtfilt" title="wyrm.processing.filtfilt"><tt class="xref py py-func docutils literal"><span class="pre">filtfilt()</span></tt></a>, <tt class="xref py py-func docutils literal"><span class="pre">scipy.signal.lfilter()</span></tt>, <tt class="xref py py-func docutils literal"><span class="pre">scipy.signal.butter()</span></tt>, <tt class="xref py py-func docutils literal"><span class="pre">scipy.signal.butterord()</span></tt></p>
</div>
<p class="rubric">Examples</p>
<p>Generate and use a Butterworth bandpass filter for complete
(off-line data):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># the sampling frequency of our data in Hz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">fs</span>
<span class="go">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># calculate the nyquist frequency</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fn</span> <span class="o">=</span> <span class="n">dat</span><span class="o">.</span><span class="n">fs</span> <span class="o">/</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># the desired low and high frequencies in Hz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f_low</span><span class="p">,</span> <span class="n">f_high</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">13</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># the order of the filter</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">butter_ord</span> <span class="o">=</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># calculate the filter coefficients</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">butter</span><span class="p">(</span><span class="n">butter_ord</span><span class="p">,</span> <span class="p">[</span><span class="n">f_low</span> <span class="o">/</span> <span class="n">fn</span><span class="p">,</span> <span class="n">f_high</span> <span class="o">/</span> <span class="n">fn</span><span class="p">],</span> <span class="n">btype</span><span class="o">=</span><span class="s">&#39;band&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filtered</span> <span class="o">=</span> <span class="n">lfilter</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>Similar to the above this time in an on-line setting:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># pre-calculate the filter coefficients and the initial filter</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># state</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">butter</span><span class="p">(</span><span class="n">butter_ord</span><span class="p">,</span> <span class="p">[</span><span class="n">f_low</span> <span class="o">/</span> <span class="n">fn</span><span class="p">,</span> <span class="n">f_high</span> <span class="o">/</span> <span class="n">fn</span><span class="p">],</span> <span class="n">btype</span><span class="o">=</span><span class="s">&#39;band&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filter_state</span> <span class="o">=</span> <span class="n">proc</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">lfilter_zi</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Our input will be N-dimensional (N == number of channels), so</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># we have to create the state for each dimension of the input</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filter_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">filter_state</span> <span class="k">for</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">CHANNELS</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">data</span><span class="p">,</span> <span class="n">markers</span> <span class="o">=</span> <span class="n">amp</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>
<span class="gp">... </span>    <span class="c"># convert incoming data into ``Data`` object</span>
<span class="gp">... </span>    <span class="n">cnt</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
<span class="gp">... </span>    <span class="c"># filter the data, note how filter now also returns the</span>
<span class="gp">... </span>    <span class="c"># filter state which we feed back into the next call of</span>
<span class="gp">... </span>    <span class="c"># ``filter``</span>
<span class="gp">... </span>    <span class="n">cnt</span><span class="p">,</span> <span class="n">filter_state</span> <span class="o">=</span> <span class="n">lfilter</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">zi</span><span class="o">=</span><span class="n">filter_state</span><span class="p">)</span>
<span class="gp">... </span>    <span class="o">...</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.logarithm">
<tt class="descclassname">wyrm.processing.</tt><tt class="descname">logarithm</tt><big>(</big><em>dat</em><big>)</big><a class="reference internal" href="../_modules/wyrm/processing.html#logarithm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.logarithm" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the element wise natural logarithm of <tt class="docutils literal"><span class="pre">dat.data</span></tt>.</p>
<p>Calling this method is equivalent to calling</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dat</strong> : Data</p>
<blockquote>
<div><p>a Data object</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dat</strong> : Data</p>
<blockquote class="last">
<div><p>a copy of <tt class="docutils literal"><span class="pre">dat</span></tt> with the element wise natural logarithms of
the values in <tt class="docutils literal"><span class="pre">.data</span></tt></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#wyrm.processing.square" title="wyrm.processing.square"><tt class="xref py py-func docutils literal"><span class="pre">square()</span></tt></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.rectify_channels">
<tt class="descclassname">wyrm.processing.</tt><tt class="descname">rectify_channels</tt><big>(</big><em>dat</em><big>)</big><a class="reference internal" href="../_modules/wyrm/processing.html#rectify_channels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.rectify_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the absolute values in <tt class="docutils literal"><span class="pre">dat.data</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dat</strong> : Data</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dat</strong> : Data</p>
<blockquote class="last">
<div><p>a copy of <tt class="docutils literal"><span class="pre">dat</span></tt> with all values absolute in <tt class="docutils literal"><span class="pre">.data</span></tt></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
<span class="go">0.391987338917</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="n">rectify_channels</span><span class="p">(</span><span class="n">dat</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
<span class="go">22.40234266</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.remove_channels">
<tt class="descclassname">wyrm.processing.</tt><tt class="descname">remove_channels</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../_modules/wyrm/processing.html#remove_channels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.remove_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove channels from data.</p>
<p>This method just calls <a class="reference internal" href="#wyrm.processing.select_channels" title="wyrm.processing.select_channels"><tt class="xref py py-func docutils literal"><span class="pre">select_channels()</span></tt></a> with the same
parameters and the <tt class="docutils literal"><span class="pre">invert</span></tt> parameter set to <tt class="docutils literal"><span class="pre">True</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dat</strong> : Data</p>
<blockquote class="last">
<div><p>A copy of the dat with the channels removed.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#wyrm.processing.select_channels" title="wyrm.processing.select_channels"><tt class="xref py py-obj docutils literal"><span class="pre">select_channels</span></tt></a></dt>
<dd>Select Channels</dd>
</dl>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.remove_classes">
<tt class="descclassname">wyrm.processing.</tt><tt class="descname">remove_classes</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../_modules/wyrm/processing.html#remove_classes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.remove_classes" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove classes from an epoched Data object.</p>
<p>This method just calls <a class="reference internal" href="#wyrm.processing.select_epochs" title="wyrm.processing.select_epochs"><tt class="xref py py-func docutils literal"><span class="pre">select_epochs()</span></tt></a> with the <tt class="docutils literal"><span class="pre">inverse</span></tt>
parameter set to <tt class="docutils literal"><span class="pre">True</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dat</strong> : Data</p>
<blockquote class="last">
<div><p>copy of Data object with the classes removed</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#wyrm.processing.select_classes" title="wyrm.processing.select_classes"><tt class="xref py py-obj docutils literal"><span class="pre">select_classes</span></tt></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.remove_epochs">
<tt class="descclassname">wyrm.processing.</tt><tt class="descname">remove_epochs</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../_modules/wyrm/processing.html#remove_epochs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.remove_epochs" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove epochs from an epoched Data object.</p>
<p>This method just calls <a class="reference internal" href="#wyrm.processing.select_epochs" title="wyrm.processing.select_epochs"><tt class="xref py py-func docutils literal"><span class="pre">select_epochs()</span></tt></a> with the <tt class="docutils literal"><span class="pre">inverse</span></tt>
paramerter set to <tt class="docutils literal"><span class="pre">True</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dat</strong> : Data</p>
<blockquote class="last">
<div><p>epoched Data object with the epochs removed</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#wyrm.processing.select_epochs" title="wyrm.processing.select_epochs"><tt class="xref py py-obj docutils literal"><span class="pre">select_epochs</span></tt></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.segment_dat">
<tt class="descclassname">wyrm.processing.</tt><tt class="descname">segment_dat</tt><big>(</big><em>dat</em>, <em>marker_def</em>, <em>ival</em>, <em>newsamples=None</em>, <em>timeaxis=-2</em><big>)</big><a class="reference internal" href="../_modules/wyrm/processing.html#segment_dat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.segment_dat" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a continuous data object to an epoched one.</p>
<p>Given a continuous data object, a definition of classes, and an
interval, this method looks for markers as defined in <tt class="docutils literal"><span class="pre">marker_def</span></tt>
and slices the dat according to the time interval given with
<tt class="docutils literal"><span class="pre">ival</span></tt> along the <tt class="docutils literal"><span class="pre">timeaxis</span></tt>. The returned <tt class="docutils literal"><span class="pre">dat</span></tt> object stores
those slices and the class each slice belongs to.</p>
<p>Epochs that are too close to the borders and thus too short are
ignored.</p>
<p>If the segmentation does not result in any epochs (i.e. the markers
in <tt class="docutils literal"><span class="pre">marker_def</span></tt> could not be found in <tt class="docutils literal"><span class="pre">dat</span></tt>, the resulting
dat.data will be an empty array.</p>
<p>This method is also suitable for <strong>online processing</strong>, please read
the documentation for the <tt class="docutils literal"><span class="pre">newsamples</span></tt> parameter and have a look
at the Examples below.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dat</strong> : Data</p>
<blockquote>
<div><p>the data object to be segmented</p>
</div></blockquote>
<p><strong>marker_def</strong> : dict</p>
<blockquote>
<div><p>The keys are class names, the values are lists of markers</p>
</div></blockquote>
<p><strong>ival</strong> : [int, int]</p>
<blockquote>
<div><p>The interval in milliseconds to cut around the markers. I.e. to
get the interval starting with the marker plus the remaining
100ms define the interval like [0, 100]. The start point is
included, the endpoint is not (like: <tt class="docutils literal"><span class="pre">[start,</span> <span class="pre">end)</span></tt>).  To get
200ms before the marker until 100ms after the marker do:
<tt class="docutils literal"><span class="pre">[-200,</span> <span class="pre">100]</span></tt> Only negative or positive values are possible
(i.e. <tt class="docutils literal"><span class="pre">[-500,</span> <span class="pre">-100]</span></tt>)</p>
</div></blockquote>
<p><strong>newsamples</strong> : int, optional</p>
<blockquote>
<div><p>consider the last <tt class="docutils literal"><span class="pre">newsamples</span></tt> samples as new data and only
return epochs which are possible with the old <strong>and</strong> the new
data (i.e. don&#8217;t include epochs which where possible without the
new data).</p>
<p>If this parameter is <tt class="docutils literal"><span class="pre">None</span></tt> (default) <tt class="docutils literal"><span class="pre">segment_dat</span></tt> will
always process the whole <tt class="docutils literal"><span class="pre">dat</span></tt>, this is what you want for
offline experiments where you process the whole data from a file
at once. In online experiments however one usually gets the data
incrementally, stores it in a ringbuffer to get the last n
milliseconds. Consequently <tt class="docutils literal"><span class="pre">segment_dat</span></tt> gets overlapping data
in each iteration (the amount of overlap is exactly the data -
the new samples. To make sure each epoch appears only once
within all iterations, <tt class="docutils literal"><span class="pre">segment_dat</span></tt> needs to know the number
of new samples.</p>
</div></blockquote>
<p><strong>timeaxis</strong> : int, optional</p>
<blockquote>
<div><p>the axis along which the segmentation will take place</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dat</strong> : Data</p>
<blockquote>
<div><p>a copy of the resulting epoched data.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>AssertionError</strong> :</p>
<blockquote class="last">
<div><ul class="simple">
<li>if <tt class="docutils literal"><span class="pre">dat</span></tt> has not <tt class="docutils literal"><span class="pre">.fs</span></tt> or <tt class="docutils literal"><span class="pre">.markers</span></tt> attribute or if
<tt class="docutils literal"><span class="pre">ival[0]</span> <span class="pre">&gt;</span> <span class="pre">ival[1]</span></tt>.</li>
<li>if <tt class="docutils literal"><span class="pre">newsamples</span></tt> is not <tt class="docutils literal"><span class="pre">None</span></tt> or positive</li>
</ul>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Offline Experiment</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Define the markers belonging to class 1 and 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">md</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;class 1&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s">&#39;S1&#39;</span><span class="p">,</span> <span class="s">&#39;S2&#39;</span><span class="p">],</span>
<span class="gp">... </span>      <span class="s">&#39;class 2&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s">&#39;S3&#39;</span><span class="p">,</span> <span class="s">&#39;S4&#39;</span><span class="p">]</span>
<span class="gp">... </span>     <span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Epoch the data -500ms and +700ms around the markers defined in</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># md</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">epo</span> <span class="o">=</span> <span class="n">segment_dat</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">md</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">500</span><span class="p">,</span> <span class="mi">700</span><span class="p">])</span>
</pre></div>
</div>
<p>Online Experiment</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Define the markers belonging to class 1 and 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">md</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;class 1&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s">&#39;S1&#39;</span><span class="p">,</span> <span class="s">&#39;S2&#39;</span><span class="p">],</span>
<span class="gp">... </span>      <span class="s">&#39;class 2&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s">&#39;S3&#39;</span><span class="p">,</span> <span class="s">&#39;S4&#39;</span><span class="p">]</span>
<span class="gp">... </span>     <span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># define the interval to epoch around a marker</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ival</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">300</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">dat</span><span class="p">,</span> <span class="n">mrk</span> <span class="o">=</span> <span class="n">amp</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>
<span class="gp">... </span>    <span class="n">newsamples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dat</span><span class="p">)</span>
<span class="gp">... </span>    <span class="c"># the ringbuffer shall keep the last 2000 milliseconds,</span>
<span class="gp">... </span>    <span class="c"># which is way bigger than our ival...</span>
<span class="gp">... </span>    <span class="n">ringbuffer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="n">mrk</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">cnt</span><span class="p">,</span> <span class="n">mrk</span> <span class="o">=</span> <span class="n">ringbuffer</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
<span class="gp">... </span>    <span class="c"># cnt contains now data up to 2000 millisecons, to make sure</span>
<span class="gp">... </span>    <span class="c"># we don&#39;t see old markers again and again until they where</span>
<span class="gp">... </span>    <span class="c"># pushed out of the ringbuffer, we need to tell segment_dat</span>
<span class="gp">... </span>    <span class="c"># how many samples of cnt are actually new</span>
<span class="gp">... </span>    <span class="n">epo</span> <span class="o">=</span> <span class="n">segment_dat</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">md</span><span class="p">,</span> <span class="n">ival</span><span class="p">,</span> <span class="n">newsamples</span><span class="o">=</span><span class="n">newsamples</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.select_channels">
<tt class="descclassname">wyrm.processing.</tt><tt class="descname">select_channels</tt><big>(</big><em>dat</em>, <em>regexp_list</em>, <em>invert=False</em>, <em>chanaxis=-1</em><big>)</big><a class="reference internal" href="../_modules/wyrm/processing.html#select_channels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.select_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>Select channels from data.</p>
<p>The matching is case-insensitive and locale-aware (as in
<tt class="docutils literal"><span class="pre">re.IGNORECASE</span></tt> and <tt class="docutils literal"><span class="pre">re.LOCALE</span></tt>). The regular expression always
has to match the whole channel name string</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dat</strong> : Data</p>
<p><strong>regexp_list</strong> : list of regular expressions</p>
<blockquote>
<div><p>The regular expressions provided, are used directly by Python&#8217;s
<a class="reference external" href="http://docs.python.org/library/re.html#module-re" title="(in Python v2.7)"><tt class="xref py py-mod docutils literal"><span class="pre">re</span></tt></a> module, so all regular expressions which are understood
by this module are allowed.</p>
<p>Internally the <a class="reference external" href="http://docs.python.org/library/re.html#re.match" title="(in Python v2.7)"><tt class="xref py py-func docutils literal"><span class="pre">re.match()</span></tt></a> method is used, additionally to
check for a match (which also matches substrings), it is also
checked if the whole string matched the pattern.</p>
</div></blockquote>
<p><strong>invert</strong> : Boolean, optional</p>
<blockquote>
<div><p>If True the selection is inverted. Instead of selecting specific
channels, you are removing the channels. (default: False)</p>
</div></blockquote>
<p><strong>chanaxis</strong> : int, optional</p>
<blockquote>
<div><p>the index of the channel axis in <tt class="docutils literal"><span class="pre">dat</span></tt> (default: -1)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dat</strong> : Data</p>
<blockquote class="last">
<div><p>A copy of <tt class="docutils literal"><span class="pre">dat</span></tt> with the channels, matched by the list of
regular expressions.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#wyrm.processing.remove_channels" title="wyrm.processing.remove_channels"><tt class="xref py py-obj docutils literal"><span class="pre">remove_channels</span></tt></a></dt>
<dd>Remove Channels</dd>
<dt><a class="reference external" href="http://docs.python.org/library/re.html#module-re" title="(in Python v2.7)"><tt class="xref py py-obj docutils literal"><span class="pre">re</span></tt></a></dt>
<dd>Python&#8217;s Regular Expression module for more information about regular expressions.</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>Select all channels Matching &#8216;af.*&#8217; or &#8216;fc.*&#8217;</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dat_new</span> <span class="o">=</span> <span class="n">select_channels</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;af.*&#39;</span><span class="p">,</span> <span class="s">&#39;fc.*&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>Remove all channels Matching &#8216;emg.*&#8217; or &#8216;eog.*&#8217;</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dat_new</span> <span class="o">=</span> <span class="n">select_channels</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;emg.*&#39;</span><span class="p">,</span> <span class="s">&#39;eog.*&#39;</span><span class="p">],</span> <span class="n">invert</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Even if you only provide one Regular expression, it has to be in an
array:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dat_new</span> <span class="o">=</span> <span class="n">select_channels</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;af.*&#39;</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.select_classes">
<tt class="descclassname">wyrm.processing.</tt><tt class="descname">select_classes</tt><big>(</big><em>dat</em>, <em>indices</em>, <em>invert=False</em>, <em>classaxis=0</em><big>)</big><a class="reference internal" href="../_modules/wyrm/processing.html#select_classes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.select_classes" title="Permalink to this definition">¶</a></dt>
<dd><p>Select classes from an epoched data object.</p>
<p>This method selects the classes with the specified indices.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dat</strong> : Data</p>
<blockquote>
<div><p>epoched Data object</p>
</div></blockquote>
<p><strong>indices</strong> : array of ints</p>
<blockquote>
<div><p>The indices of the classes to select.</p>
</div></blockquote>
<p><strong>invert</strong> : Boolean, optional</p>
<blockquote>
<div><p>if true keep all classes except the ones defined by <tt class="docutils literal"><span class="pre">indices</span></tt>.</p>
</div></blockquote>
<p><strong>classaxis</strong> : int, optional</p>
<blockquote>
<div><p>the axis along which the classes are selected</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dat</strong> : Data</p>
<blockquote>
<div><p>a copy of the epoched data with only the selected classes
included.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>AssertionError</strong> :</p>
<blockquote class="last">
<div><p>if <tt class="docutils literal"><span class="pre">dat</span></tt> has no <tt class="docutils literal"><span class="pre">.class_names</span></tt> attribute.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#wyrm.processing.remove_classes" title="wyrm.processing.remove_classes"><tt class="xref py py-obj docutils literal"><span class="pre">remove_classes</span></tt></a></p>
</div>
<p class="rubric">Examples</p>
<p>Get the classes 1 and 2.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">[0, 0, 1, 2, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="n">select_classes</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">[1, 2, 2]</span>
</pre></div>
</div>
<p>Remove class 2</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">[0, 0, 1, 2, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="n">select_classes</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">invert</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">[0, 0, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.select_epochs">
<tt class="descclassname">wyrm.processing.</tt><tt class="descname">select_epochs</tt><big>(</big><em>dat</em>, <em>indices</em>, <em>invert=False</em>, <em>classaxis=0</em><big>)</big><a class="reference internal" href="../_modules/wyrm/processing.html#select_epochs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.select_epochs" title="Permalink to this definition">¶</a></dt>
<dd><p>Select epochs from an epoched data object.</p>
<p>This method selects the epochs with the specified indices.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dat</strong> : Data</p>
<blockquote>
<div><p>epoched Data object with an <tt class="docutils literal"><span class="pre">.class_names</span></tt> attribute</p>
</div></blockquote>
<p><strong>indices</strong> : array of ints</p>
<blockquote>
<div><p>The indices of the elements to select.</p>
</div></blockquote>
<p><strong>invert</strong> : Boolean, optional</p>
<blockquote>
<div><p>if true keep all elements except the ones defined by <tt class="docutils literal"><span class="pre">indices</span></tt>.</p>
</div></blockquote>
<p><strong>classaxis</strong> : int, optional</p>
<blockquote>
<div><p>the axis along which the epochs are selected</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dat</strong> : Data</p>
<blockquote>
<div><p>a copy of the epoched data with only the selected epochs included.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>AssertionError</strong> :</p>
<blockquote class="last">
<div><p>if <tt class="docutils literal"><span class="pre">dat</span></tt> has no <tt class="docutils literal"><span class="pre">.class_names</span></tt> attribute.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#wyrm.processing.remove_epochs" title="wyrm.processing.remove_epochs"><tt class="xref py py-obj docutils literal"><span class="pre">remove_epochs</span></tt></a></p>
</div>
<p class="rubric">Examples</p>
<p>Get the first three epochs.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">[0, 0, 1, 2, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="n">select_epochs</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">[0, 0, 1]</span>
</pre></div>
</div>
<p>Remove the fourth epoch</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">[0, 0, 1, 2, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="n">select_epochs</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">invert</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">[0, 0, 1, 2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.select_ival">
<tt class="descclassname">wyrm.processing.</tt><tt class="descname">select_ival</tt><big>(</big><em>dat</em>, <em>ival</em>, <em>timeaxis=-2</em><big>)</big><a class="reference internal" href="../_modules/wyrm/processing.html#select_ival"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.select_ival" title="Permalink to this definition">¶</a></dt>
<dd><p>Select interval from data.</p>
<p>This method selects the time segment(s) defined by <tt class="docutils literal"><span class="pre">ival</span></tt>. It will
also automatically remove markers outside of the desired interval in
the returned Data object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dat</strong> : Data</p>
<p><strong>ival</strong> : list of two floats</p>
<blockquote>
<div><p>Start and end in milliseconds. Start is included end is excluded
(like <tt class="docutils literal"><span class="pre">[stard,</span> <span class="pre">end)</span></tt>]</p>
</div></blockquote>
<p><strong>timeaxis</strong> : int, optional</p>
<blockquote>
<div><p>the axis along which the intervals are selected</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dat</strong> : Data</p>
<blockquote>
<div><p>a copy of <tt class="docutils literal"><span class="pre">dat</span></tt> with the selected time intervals.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>AssertionError</strong> :</p>
<blockquote class="last">
<div><p>if the given interval does not fit into <tt class="docutils literal"><span class="pre">dat.axes[timeaxis]</span></tt>
or <tt class="docutils literal"><span class="pre">ival[0]</span> <span class="pre">&gt;</span> <span class="pre">ival[1]</span></tt>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Select the first 200ms of the epoched data:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">fs</span>
<span class="go">100.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat2</span> <span class="o">=</span> <span class="n">select_ival</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">200</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">dat2</span><span class="o">.</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dat2</span><span class="o">.</span><span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">0. 199.</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.spectrogram">
<tt class="descclassname">wyrm.processing.</tt><tt class="descname">spectrogram</tt><big>(</big><em>cnt</em><big>)</big><a class="reference internal" href="../_modules/wyrm/processing.html#spectrogram"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.spectrogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the spectrogram of a continuous data object.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#wyrm.processing.spectrum" title="wyrm.processing.spectrum"><tt class="xref py py-obj docutils literal"><span class="pre">spectrum</span></tt></a>, <a class="reference internal" href="#wyrm.processing.stft" title="wyrm.processing.stft"><tt class="xref py py-obj docutils literal"><span class="pre">stft</span></tt></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.spectrum">
<tt class="descclassname">wyrm.processing.</tt><tt class="descname">spectrum</tt><big>(</big><em>dat</em>, <em>timeaxis=-2</em><big>)</big><a class="reference internal" href="../_modules/wyrm/processing.html#spectrum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the spectrum of a data object.</p>
<p>This method performs a fast fourier transform on the data along the
timeaxis and returns a new <cite>Data</cite> object which is transformed into
the frequency domain. The values are the amplitudes of of the
respective frequencies.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dat</strong> : Data</p>
<blockquote>
<div><p>Data object with <cite>.fs</cite> attribute</p>
</div></blockquote>
<p><strong>timeaxis</strong> : int, optional</p>
<blockquote>
<div><p>axis to perform the fft along</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dat</strong> : Data</p>
<blockquote>
<div><p>Data object with the timeaxis transformed into the frequency
domain. The values of the spectrum are the amplitudes of the
respective frequencies.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>AssertionError</strong> :</p>
<blockquote class="last">
<div><p>if the <tt class="docutils literal"><span class="pre">dat</span></tt> parameter has no <tt class="docutils literal"><span class="pre">.fs</span></tt> attribute</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#wyrm.processing.spectrogram" title="wyrm.processing.spectrogram"><tt class="xref py py-obj docutils literal"><span class="pre">spectrogram</span></tt></a>, <a class="reference internal" href="#wyrm.processing.stft" title="wyrm.processing.stft"><tt class="xref py py-obj docutils literal"><span class="pre">stft</span></tt></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># dat can be continuous or epoched</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">axes</span>
<span class="go">[&#39;time&#39;, &#39;channel&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spm</span> <span class="o">=</span> <span class="n">spectrum</span><span class="p">(</span><span class="n">dat</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spm</span><span class="o">.</span><span class="n">axes</span>
<span class="go">[&#39;frequency&#39;, &#39;channel&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.square">
<tt class="descclassname">wyrm.processing.</tt><tt class="descname">square</tt><big>(</big><em>dat</em><big>)</big><a class="reference internal" href="../_modules/wyrm/processing.html#square"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.square" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the element wise square of <tt class="docutils literal"><span class="pre">dat.data</span></tt>.</p>
<p>Calling this method is equivalent to calling</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dat</strong> : Data</p>
<blockquote>
<div><p>a Data object</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dat</strong> : Data</p>
<blockquote class="last">
<div><p>a copy of <tt class="docutils literal"><span class="pre">dat</span></tt> with the element wise squares of the values in
<tt class="docutils literal"><span class="pre">.data</span></tt></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#wyrm.processing.logarithm" title="wyrm.processing.logarithm"><tt class="xref py py-func docutils literal"><span class="pre">logarithm()</span></tt></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.stft">
<tt class="descclassname">wyrm.processing.</tt><tt class="descname">stft</tt><big>(</big><em>x</em>, <em>width</em><big>)</big><a class="reference internal" href="../_modules/wyrm/processing.html#stft"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.stft" title="Permalink to this definition">¶</a></dt>
<dd><p>Short time fourier transform of a real sequence.</p>
<p>This method performs a discrete short time Fourier transform. It
uses a sliding window to perform discrete Fourier transforms on the
data in the Window. The results are returned in an array.</p>
<p>This method uses a Hanning window on the data in the window before
calculating the Fourier transform.</p>
<p>The sliding windows are overlapping by <tt class="docutils literal"><span class="pre">width</span> <span class="pre">/</span> <span class="pre">2</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x</strong> : ndarray</p>
<p><strong>width: int</strong> :</p>
<blockquote>
<div><p>the width of the sliding window in samples</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fourier</strong> : 2d complex array</p>
<blockquote class="last">
<div><p>the dimensions are time, frequency; the frequencies are evenly
binned from 0 to f_nyquist</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#wyrm.processing.spectrum" title="wyrm.processing.spectrum"><tt class="xref py py-obj docutils literal"><span class="pre">spectrum</span></tt></a>, <a class="reference internal" href="#wyrm.processing.spectrogram" title="wyrm.processing.spectrogram"><tt class="xref py py-obj docutils literal"><span class="pre">spectrogram</span></tt></a>, <tt class="xref py py-obj docutils literal"><span class="pre">scipy.hanning</span></tt>, <tt class="xref py py-obj docutils literal"><span class="pre">scipy.fftpack.rfft</span></tt></p>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.subsample">
<tt class="descclassname">wyrm.processing.</tt><tt class="descname">subsample</tt><big>(</big><em>dat</em>, <em>freq</em>, <em>timeaxis=-2</em><big>)</big><a class="reference internal" href="../_modules/wyrm/processing.html#subsample"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.subsample" title="Permalink to this definition">¶</a></dt>
<dd><p>Subsample the data to <tt class="docutils literal"><span class="pre">freq</span></tt> Hz.</p>
<p>This method subsamples data along <tt class="docutils literal"><span class="pre">timeaxis</span></tt> by taking every <tt class="docutils literal"><span class="pre">n</span></tt>
th element starting with the first one and <tt class="docutils literal"><span class="pre">n</span></tt> being <tt class="docutils literal"><span class="pre">dat.fs</span> <span class="pre">/</span>
<span class="pre">freq</span></tt>. Please note that <tt class="docutils literal"><span class="pre">freq</span></tt> must be a whole number divisor of
<tt class="docutils literal"><span class="pre">dat.fs</span></tt>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Note that this method does not low-pass filter the data before
sub-sampling.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>If you use this method in an on-line setting (i.e. where you
process the data in chunks and not as a whole), you should make
sure that <tt class="docutils literal"><span class="pre">subsample</span></tt> does not drop &#8220;half samples&#8221; by ensuring
the source data&#8217;s length is in multiples of the target data&#8217;s
sample length.</p>
<p class="last">Let&#8217;s assume your source data is sampled in 1kHz and you want to
subsample down to 100Hz. One sample of the source data is 1ms
long, while the target samples will be 10ms long. In order to
ensure that <tt class="docutils literal"><span class="pre">subsample</span></tt> does not eat fractions of samples at
the end of your data, you have to make sure that your source
data is multiples of 10ms (i.e. 1010, 1020, etc) long. You might
want to use <a class="reference internal" href="#wyrm.types.BlockBuffer" title="wyrm.types.BlockBuffer"><tt class="xref py py-class docutils literal"><span class="pre">wyrm.types.BlockBuffer</span></tt></a> for this (see
Examples below).</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dat</strong> : Data</p>
<blockquote>
<div><p>Data object with <tt class="docutils literal"><span class="pre">.fs</span></tt> attribute</p>
</div></blockquote>
<p><strong>freq</strong> : float</p>
<blockquote>
<div><p>the target frequency in Hz</p>
</div></blockquote>
<p><strong>timeaxis</strong> : int, optional</p>
<blockquote>
<div><p>the axis along which to subsample</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dat</strong> : Data</p>
<blockquote>
<div><p>copy of <tt class="docutils literal"><span class="pre">dat</span></tt> with subsampled frequency</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>AssertionError</strong> :</p>
<blockquote class="last">
<div><ul class="simple">
<li>if <tt class="docutils literal"><span class="pre">freq</span></tt> is not a whole number divisor of <tt class="docutils literal"><span class="pre">dat.fs</span></tt></li>
<li>if <tt class="docutils literal"><span class="pre">dat</span></tt> has no <tt class="docutils literal"><span class="pre">.fs</span></tt> attribute</li>
<li>if <tt class="docutils literal"><span class="pre">dat.data.shape[timeaxis]</span> <span class="pre">!=</span> <span class="pre">len(dat.axes[timeaxis])</span></tt></li>
</ul>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#wyrm.processing.lfilter" title="wyrm.processing.lfilter"><tt class="xref py py-obj docutils literal"><span class="pre">lfilter</span></tt></a></p>
</div>
<p class="rubric">Examples</p>
<p>Load some EEG data with 1kHz, bandpass filter it and downsample it
to 100Hz.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="n">load_brain_vision_data</span><span class="p">(</span><span class="s">&#39;some/path&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">fs</span>
<span class="go">1000.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fn</span> <span class="o">=</span> <span class="n">dat</span><span class="o">.</span><span class="n">fs</span> <span class="o">/</span> <span class="mi">2</span> <span class="c"># nyquist frequ</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">butter</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="p">[</span><span class="mi">8</span> <span class="o">/</span> <span class="n">fn</span><span class="p">,</span> <span class="mi">40</span> <span class="o">/</span> <span class="n">fn</span><span class="p">],</span> <span class="n">btype</span><span class="o">=</span><span class="s">&#39;band&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="n">lfilter</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="n">subsample</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">fs</span>
<span class="go">100.0</span>
</pre></div>
</div>
<p>Online Experiment</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">bbuffer</span> <span class="o">=</span> <span class="n">BlockBuffer</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="c"># 10 ms is the target block size</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">cnt</span> <span class="o">=</span> <span class="o">...</span> <span class="c"># get 1kHz continous data from your amp</span>
<span class="gp">... </span>    <span class="c"># put the data into the block buffer</span>
<span class="gp">... </span>    <span class="c"># bbget will onlry return the data in multiples of 10ms or</span>
<span class="gp">... </span>    <span class="c"># nothing</span>
<span class="gp">... </span>    <span class="n">bbuffer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cnt</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">cnt</span> <span class="o">=</span> <span class="n">bbuffer</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="ow">not</span> <span class="n">cnt</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">continue</span>
<span class="gp">... </span>    <span class="c"># filter, etc</span>
<span class="gp">... </span>    <span class="n">subsample</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.swapaxes">
<tt class="descclassname">wyrm.processing.</tt><tt class="descname">swapaxes</tt><big>(</big><em>dat</em>, <em>ax1</em>, <em>ax2</em><big>)</big><a class="reference internal" href="../_modules/wyrm/processing.html#swapaxes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.swapaxes" title="Permalink to this definition">¶</a></dt>
<dd><p>Swap axes of a Data object.</p>
<p>This method swaps two axes of a Data object by swapping the
appropriate <tt class="docutils literal"><span class="pre">.data</span></tt>, <tt class="docutils literal"><span class="pre">.names</span></tt>, <tt class="docutils literal"><span class="pre">.units</span></tt>, and <tt class="docutils literal"><span class="pre">.axes</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dat</strong> : Data</p>
<p><strong>ax1, ax2</strong> : int</p>
<blockquote>
<div><p>the indices of the axes to swap</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dat</strong> : Data</p>
<blockquote class="last">
<div><p>a copy of <tt class="docutils literal"><span class="pre">dat</span></tt> with the appropriate axes swapped.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-obj docutils literal"><span class="pre">numpy.swapaxes</span></tt></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">names</span>
<span class="go">[&#39;time&#39;, &#39;channels&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="n">swapaxes</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">names</span>
<span class="go">[&#39;channels&#39;, &#39;time&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="wyrm.processing.variance">
<tt class="descclassname">wyrm.processing.</tt><tt class="descname">variance</tt><big>(</big><em>dat</em>, <em>timeaxis=-2</em><big>)</big><a class="reference internal" href="../_modules/wyrm/processing.html#variance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.processing.variance" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the variance along the <tt class="docutils literal"><span class="pre">timeaxis</span></tt> of <tt class="docutils literal"><span class="pre">dat</span></tt>.</p>
<p>This method reduces the dimensions of <cite>dat.data</cite> by one.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dat</strong> : Data</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dat</strong> : Data</p>
<blockquote class="last">
<div><p>copy of <tt class="docutils literal"><span class="pre">dat</span></tt> with with the variance along the <tt class="docutils literal"><span class="pre">timeaxis</span></tt>
removed and <tt class="docutils literal"><span class="pre">timeaxis</span></tt> removed.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">epo</span><span class="o">.</span><span class="n">names</span>
<span class="go">[&#39;class&#39;, &#39;time&#39;, &#39;channel&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">var</span> <span class="o">=</span> <span class="n">variance</span><span class="p">(</span><span class="n">cnt</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">var</span><span class="o">.</span><span class="n">names</span>
<span class="go">[&#39;class&#39;, &#39;channel&#39;]</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-wyrm.types">
<span id="wyrm-types-module"></span><h2>wyrm.types module<a class="headerlink" href="#module-wyrm.types" title="Permalink to this headline">¶</a></h2>
<p>Data type definitions.</p>
<p>This module provides the basic data types for Wyrm, like the
<a class="reference internal" href="#wyrm.types.Data" title="wyrm.types.Data"><tt class="xref py py-class docutils literal"><span class="pre">Data</span></tt></a> and <a class="reference internal" href="#wyrm.types.RingBuffer" title="wyrm.types.RingBuffer"><tt class="xref py py-class docutils literal"><span class="pre">RingBuffer</span></tt></a> classes.</p>
<dl class="class">
<dt id="wyrm.types.BlockBuffer">
<em class="property">class </em><tt class="descclassname">wyrm.types.</tt><tt class="descname">BlockBuffer</tt><big>(</big><em>block_length=50</em><big>)</big><a class="reference internal" href="../_modules/wyrm/types.html#BlockBuffer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.types.BlockBuffer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A buffer that returns data chunks in multiples of a block length.</p>
<p>This buffer is a first-in-first-out (FIFO) buffer that returns data
in multiples of a desired block length. The block length is defined
in milliseconds.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>block_legnth</strong> : int, optional</p>
<blockquote class="last">
<div><p>the desired block length in ms</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">bbuffer</span> <span class="o">=</span> <span class="n">BlockBuffer</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
<span class="gp">... </span><span class="n">cnt</span> <span class="o">=</span> <span class="n">some_aquisition_method</span><span class="p">()</span>
<span class="gp">... </span><span class="c"># How to use the BlockBuffer</span>
<span class="gp">... </span><span class="n">bbuffer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cnt</span><span class="p">)</span>
<span class="gp">... </span><span class="n">cnt</span> <span class="o">=</span> <span class="n">bbuffer</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
<span class="gp">... </span><span class="k">if</span> <span class="ow">not</span> <span class="n">cnt</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">continue</span>
<span class="gp">... </span><span class="c"># after here cnt is guaranteed to be in multiples of 10ms</span>
</pre></div>
</div>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#wyrm.types.BlockBuffer.append" title="wyrm.types.BlockBuffer.append"><tt class="xref py py-obj docutils literal"><span class="pre">append</span></tt></a>(dat)</td>
<td>Append data to the Block Buffer.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#wyrm.types.BlockBuffer.get" title="wyrm.types.BlockBuffer.get"><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt></a>()</td>
<td>Pop the contents of the Block Buffer.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="wyrm.types.BlockBuffer.append">
<tt class="descname">append</tt><big>(</big><em>dat</em><big>)</big><a class="reference internal" href="../_modules/wyrm/types.html#BlockBuffer.append"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.types.BlockBuffer.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Append data to the Block Buffer.</p>
<p>This method accumulates the incoming data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dat</strong> : Data</p>
<blockquote class="last">
<div><p>continuous Data object</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="wyrm.types.BlockBuffer.get">
<tt class="descname">get</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/wyrm/types.html#BlockBuffer.get"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.types.BlockBuffer.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Pop the contents of the Block Buffer.</p>
<p>The data returned has a length of multiples of <tt class="docutils literal"><span class="pre">block_length</span></tt>.
If there is a fraction of <tt class="docutils literal"><span class="pre">block_length</span></tt> data more in the
buffer, that data is kept and future <a class="reference internal" href="#wyrm.types.BlockBuffer.append" title="wyrm.types.BlockBuffer.append"><tt class="xref py py-meth docutils literal"><span class="pre">append()</span></tt></a> operations
will append new data to it.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dat</strong> : Data</p>
<blockquote class="last">
<div><p>continuous Data object</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="wyrm.types.Data">
<em class="property">class </em><tt class="descclassname">wyrm.types.</tt><tt class="descname">Data</tt><big>(</big><em>data</em>, <em>axes</em>, <em>names</em>, <em>units</em><big>)</big><a class="reference internal" href="../_modules/wyrm/types.html#Data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.types.Data" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Generic, self-describing data container.</p>
<p>This data structure is very generic on purpose. The goal here was to
provide something which can fit the various different known and yet
unknown requirements for BCI algorithms.</p>
<p>At the core of <tt class="docutils literal"><span class="pre">Data</span></tt> is its n-dimensional <tt class="docutils literal"><span class="pre">.data</span></tt> attribute
which holds the actual data. Along with the data, there is meta
information about each axis of the data, contained in <tt class="docutils literal"><span class="pre">.axes</span></tt>,
<tt class="docutils literal"><span class="pre">.names</span></tt>, and <tt class="docutils literal"><span class="pre">.units</span></tt>.</p>
<p>Most toolbox methods rely on a <em>convention</em> how specific data should
be structured (i.e. they assume that the channels are always in the
last dimension). You don&#8217;t have to follow this convention (or
sometimes it might not even be possible when trying out new things),
and all methods, provide an optional parameter to tell them on which
axis they should work on.</p>
<dl class="docutils">
<dt>Continuous Data:</dt>
<dd>Continuous Data is usually EEG data and consists of a 2d array
<tt class="docutils literal"><span class="pre">[time,</span> <span class="pre">channel]</span></tt>. Whenever you have continuous data, time and
channel should be the last two dimensions.</dd>
<dt>Epoched Data:</dt>
<dd>Epoched data can be seen as an array of (non-epoched) data. The
epoch should always be the first dimension. Most commonly used is
epoched continuous EEG data which looks like this: <tt class="docutils literal"><span class="pre">[class,</span>
<span class="pre">time,</span> <span class="pre">channel]</span></tt>.</dd>
<dt>Feature Vector:</dt>
<dd>Similar to Epoched Data, with classes in the first dimension.</dd>
</dl>
<p><tt class="xref py py-meth docutils literal"><span class="pre">Data.__eq__()</span></tt> and <tt class="xref py py-meth docutils literal"><span class="pre">Data.__ne__()</span></tt> functions are provided
to test for equality of two Data objects (via <tt class="docutils literal"><span class="pre">==</span></tt> and <tt class="docutils literal"><span class="pre">!=</span></tt>).
This method only checks for the known attributes and does not
guaranty correct result if the Data object contains custom
attributes. It is mainly used in unittests.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : ndarray</p>
<p><strong>axes</strong> : nlist of 1darrays</p>
<p><strong>names</strong> : nlist of strings</p>
<p class="last"><strong>units</strong> : nlist of strings</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Attributes</p>
<table border="1" class="docutils">
<colgroup>
<col width="6%" />
<col width="21%" />
<col width="74%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>data</td>
<td>ndarray</td>
<td>n-dimensional data array if the array is empty
(i.e. <tt class="docutils literal"><span class="pre">data.size</span> <span class="pre">==</span> <span class="pre">0</span></tt>), the <tt class="docutils literal"><span class="pre">Data</span></tt> object is assumed to be
empty</td>
</tr>
<tr class="row-even"><td>axes</td>
<td>nlist of 1-darrays</td>
<td>each element of corresponds to a dimension of <tt class="docutils literal"><span class="pre">.data</span></tt> (i.e.
the first one in <tt class="docutils literal"><span class="pre">.axes</span></tt> to the first dimension in <tt class="docutils literal"><span class="pre">.data</span></tt>
and so on). The 1-dimensional arrays contain the description of
the data along the appropriate axis in <tt class="docutils literal"><span class="pre">.data</span></tt>. For example if
<tt class="docutils literal"><span class="pre">.data</span></tt> contains Continuous Data, then <tt class="docutils literal"><span class="pre">.axes[0]</span></tt> should be
an array of timesteps and <tt class="docutils literal"><span class="pre">.axes[1]</span></tt> an array of channel names</td>
</tr>
<tr class="row-odd"><td>names</td>
<td>nlist of strings</td>
<td>the human readable description of each axis, like &#8216;time&#8217;, or
&#8216;channel&#8217;</td>
</tr>
<tr class="row-even"><td>units</td>
<td>nlist of strings</td>
<td>the human readable description of the unit used for the data in
<tt class="docutils literal"><span class="pre">.axes</span></tt></td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#wyrm.types.Data.copy" title="wyrm.types.Data.copy"><tt class="xref py py-obj docutils literal"><span class="pre">copy</span></tt></a>(**kwargs)</td>
<td>Return a memory efficient deep copy of <tt class="docutils literal"><span class="pre">self</span></tt>.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="wyrm.types.Data.copy">
<tt class="descname">copy</tt><big>(</big><em>**kwargs</em><big>)</big><a class="reference internal" href="../_modules/wyrm/types.html#Data.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.types.Data.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a memory efficient deep copy of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>It first creates a shallow copy of <tt class="docutils literal"><span class="pre">self</span></tt>, sets the attributes
in <tt class="docutils literal"><span class="pre">kwargs</span></tt> if necessary and returns a deep copy of the
resulting object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>kwargs</strong> : dict, optional</p>
<blockquote>
<div><p>if provided <tt class="docutils literal"><span class="pre">copy</span></tt> will try to overwrite the name, value
pairs after the shallow- and before the deep copy. If no
<tt class="docutils literal"><span class="pre">kwargs</span></tt> are provided, it will just return the deep copy.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dat</strong> : Data</p>
<blockquote class="last">
<div><p>a deep copy of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># perform an ordinary deep copy of dat</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat2</span> <span class="o">=</span> <span class="n">dat</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># perform a deep copy but overwrite .axes first</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">axes</span>
<span class="go">[&#39;time&#39;, &#39;channels&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat3</span> <span class="o">=</span> <span class="n">dat</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;foo&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s">&#39;bar&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat3</span><span class="o">.</span><span class="n">axes</span>
<span class="go">[&#39;foo&#39;, &#39;bar&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">axes</span>
<span class="go">[&#39;time&#39;, &#39;channel&#39;]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="wyrm.types.RingBuffer">
<em class="property">class </em><tt class="descclassname">wyrm.types.</tt><tt class="descname">RingBuffer</tt><big>(</big><em>length_ms</em><big>)</big><a class="reference internal" href="../_modules/wyrm/types.html#RingBuffer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.types.RingBuffer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Circular Buffer implementation.</p>
<p>This implementation has a guaranteed upper bound for read and write
operations as well as a constant memory usage, which is the size of
the maximum length of the buffer in memory.</p>
<p>Reading and writing will take at most the time it takes to copy a
continuous chunk of length <tt class="docutils literal"><span class="pre">MAXLEN</span></tt> in memory. E.g. for the
extreme case of storing the last 60 seconds of 64bit data, sampled
with 1kHz and 128 channels (~60MB), reading a full buffer will take
~25ms, as well as writing when storing more than than 60 seconds at
once. Writing will be usually much faster, as one stores usually
only a few milliseconds of data per run. In that case writing will
be a fraction of a millisecond.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>length_ms</strong> : int</p>
<blockquote class="last">
<div><p>the length of the ring buffer in milliseconds</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">RingBuffer</span><span class="p">(</span><span class="n">length</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">rb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">amp</span><span class="o">.</span><span class="n">get_data</span><span class="p">())</span>
<span class="gp">... </span>    <span class="n">buffered</span> <span class="o">=</span> <span class="n">rb</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
<span class="gp">... </span>    <span class="c"># do something with buffered</span>
</pre></div>
</div>
<p class="rubric">Attributes</p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="21%" />
<col width="69%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>length_ms</td>
<td>int</td>
<td>the length of the ring buffer in milliseconds</td>
</tr>
<tr class="row-even"><td>length</td>
<td>int</td>
<td>the length of the ring buffer in samples</td>
</tr>
<tr class="row-odd"><td>data</td>
<td>ndarray</td>
<td>the contents of the ring buffer, you should not read or write
this attribute directly but via the <a class="reference internal" href="#wyrm.types.RingBuffer.get" title="wyrm.types.RingBuffer.get"><tt class="xref py py-meth docutils literal"><span class="pre">RingBuffer.get()</span></tt></a> and
<a class="reference internal" href="#wyrm.types.RingBuffer.append" title="wyrm.types.RingBuffer.append"><tt class="xref py py-meth docutils literal"><span class="pre">RingBuffer.append()</span></tt></a> methods</td>
</tr>
<tr class="row-even"><td>markers</td>
<td>array of [int, str]</td>
<td>the markers belonging to the data currently in the ring buffer</td>
</tr>
<tr class="row-odd"><td>full</td>
<td>boolean</td>
<td>indicates if the buffer has at least <tt class="docutils literal"><span class="pre">length</span></tt> elements stored</td>
</tr>
<tr class="row-even"><td>idx</td>
<td>int</td>
<td>the starting position of the oldest data in the ring buffer</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#wyrm.types.RingBuffer.append" title="wyrm.types.RingBuffer.append"><tt class="xref py py-obj docutils literal"><span class="pre">append</span></tt></a>(dat)</td>
<td>Append data to the Ringbuffer, overwriting old data if necessary.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#wyrm.types.RingBuffer.get" title="wyrm.types.RingBuffer.get"><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt></a>()</td>
<td>Get all buffered data.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="wyrm.types.RingBuffer.append">
<tt class="descname">append</tt><big>(</big><em>dat</em><big>)</big><a class="reference internal" href="../_modules/wyrm/types.html#RingBuffer.append"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.types.RingBuffer.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Append data to the Ringbuffer, overwriting old data if necessary.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dat</strong> : Data</p>
<blockquote>
<div><p>a continuous data object</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>ValueError</strong> :</p>
<blockquote class="last">
<div><p>if the [1:]-dimensions (all but the first one) of <tt class="docutils literal"><span class="pre">data</span></tt>
does not match the ring buffer dimensions</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="wyrm.types.RingBuffer.get">
<tt class="descname">get</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/wyrm/types.html#RingBuffer.get"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wyrm.types.RingBuffer.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all buffered data.</p>
<p>The returned data will have <em>at most</em> the length of <tt class="docutils literal"><span class="pre">length</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>data</strong> : Data</p>
<blockquote class="last">
<div><p>the full contents of the ring buffer</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-wyrm">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-wyrm" title="Permalink to this headline">¶</a></h2>
<p>This is Wyrm.</p>
<p>Some words describing the Wyrm package.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">wyrm package</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-wyrm.io">wyrm.io module</a></li>
<li><a class="reference internal" href="#module-wyrm.plot">wyrm.plot module</a></li>
<li><a class="reference internal" href="#module-wyrm.processing">wyrm.processing module</a></li>
<li><a class="reference internal" href="#module-wyrm.types">wyrm.types module</a><ul>
</ul>
</li>
<li><a class="reference internal" href="#module-wyrm">Module contents</a></li>
</ul>
</li>
</ul>

<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">Wyrm 0.7.beta documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Bastian Venthur.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>